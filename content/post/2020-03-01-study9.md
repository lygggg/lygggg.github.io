---
title: '웹을 지탱하는 기술 문제 정리'
date: 2020-03-01
tag: ['Study']
---

1. 웹을 지탱하는 기술 3가지를 쓰고 그 관계를 설명하시오. (27~28p)

- HTML은 그 정보를 표현하는 문서형식
- HTTP라는 프로토콜을 사용하여 그 정보들을 가져오거나 내보낸다.
- URI는 리소스 식별자

2. 웹 이전의 하이퍼미디어, 분산 시스템과 비교하는 관점에서 하이퍼미디어로서의 웹, 분산시스템의로서의 웹을 설명하시오. (42~43p)

- 하이퍼미디어란 텍스트와 이미지, 음성, 영상 등 다양한 미디어를 하이퍼링크로 연결해 구성한 시스템입니다.

- 분산시스템은 복수의 컴퓨터를 조합해 처리를 분산시키는 형식

3. 웹 2.0에선 매쉬업이 중요했다. 매쉬업은 무엇인지 설명하고 이러한 흐름 속에서 REST가 승리한 요인은 무엇인가? (51~52p)

- 매쉬업이란 여러가지 웹 API가 제공하는 정보를 조합하여 하나의 애플리케이션을 실현하는 방법을 말합니다. 매쉬업에서는 가벼움이 요구되었기 떄문에, 웹 API가 제공하는 리소스를 HTTP와 URI로 간단히 조작할 수 있는 REST 스타일쪽이 받아들여졌다.

4. 아키텍처 스타일이란 무엇인가? (54p)

- 아키텍처 스타일이란 아키텍처 패턴이라고도 하며, 복수의 아키텍처의 공통된 설칠, 양식, 규정 혹은 독특한 방식을 가리키는 말이다.

5. 리소스란 무엇인가? (58p)

- 리소스란 웹살에 존재하는 이름을 가진 모든 정보다.

6. URI란 무엇인가? 또한 URI가 가진 Addressability에 대해서 설명하시오. (58~60p)

- URI는 리소스를 식별할 때 사용되며 리소스의 이름을 뜻합니다.
  - 리소스란 웹상의 정보다
  - 전 세계의 무수한 리소스는 각각의 URI로 의미 있는 이름을 가진다.
  - URI를 이용함으로써, 프로그램은 리소스가 표현하는 정보에 접근할 수 있다.
- 어드레스 가능성은 URI가 지니고 있는 리소스를 간단히 가리킬 수 있는 성질을 말한다.

7. 서버와 클라이언트 사이에 주고받는 어떤 구체적인 데이터를 무엇이라 하는가? (61p)

- 서버와 클라이언트 사이에 주고받는 데이터를 Resource Representation이라고 부릅니다.

8. REST는 복수의 아키텍처 스타일을 조합하여 구축한 복합 아키텍처 스타일이다. 6가지 아키텍처 스타일을 모두 나열하고 각 아키텍처 스타일이 주는 장점을 차례대로 모두 설명하시오. (62~69p)

- 클라이언트/서버 - 클라이언트와 서버로 분리해서 처리를 할수 있다.
- 스테이트리스 서버 - 클라이언트의 상태를 서버에 저장하지 않는다.
- 캐시 - 자주쓰는 데이터를 클라이언트에 저장해 클라이언트와 서버의 통신횟수의 양을 감소시킨다.
- 유니폼 인터페이스 - URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.
- 계층화 시스템 - 시스템을 몇 개의 계층으로 분리하는 아키텍처 스타일
- 코드 온 디맨드 - 프로그램 코드를 서버에서 다운받아 클라이언트에서 실행하는 아키텍처 스타일

9. REST의 근간을 이루는 사상인 접속성(Connectedness)이란 무엇인가? (72p)

- 리소스를 링크로 연결하여 하나의 애플리케이션을 구성한다는 개념

10. 기존 분산 시스템의 문제점과 이에 비해 REST가 갖는 장점들은 무엇인가? (72~73p)

- REST에 기초한 웹에서는 유니폼 인터페이스에 의해 인터페이스가 고정되어 있기 때문에 호환성 문제가 발생하지 않는다.

11. http://yohei:pass@blog.example.com:8000/search?q=test&debug=true#n10과 같은 URI에서 각 7개의 구성요소를 구분하여 쓰시오. (79p)

- URI 스키마 : http
- 사용자 정보 : yohei:pass
- 호스트명 : blog.example.com
- 포트번호 : 8000
- 패스 : /search
- 쿼리 파라미터: q=test&debug=true
- URI 프래그먼트 : #n10

12. 시작점이 /foo/bar/ 일 때 상대 경로 ../hoge/fuga의 절대 경로를 쓰시오. (81p)

- /foo/hoge/fuga

13. URL 구현에서 주의할 점 2가지를 모두 설명하시오. (89p)

- 가능한 절대 URI를 사용한다는것, 인코딩의 혼란을 피하기위해 UTF-8을 사용하는것

14. URI, URL, URN이 무엇인지 각각 쓰시오. (90~91p)

- URI는 리소스를 식별하는것 URL은 리소스의 위치를 나타내는것, URN은 리소스의 이름을 나타내는 것이다. URL과 URN을 합친 것이 URI다.

15. Cool URI가 무엇인지 설명하고 이를 위한한 URI 설계지침 5가지를 모두 설명하시오. (92~98p)

- Coll URI는 변하지 않는 URI를 말한다.
  1. 프로그래밍 언어에 의존적인 확장자와 경로를 포함하지 않는다.
  2. 메서드명과 세션ID를 포함하지 않는다.
  3. URI는 해당 리소스를 표현하는 명사다.

16. URI의 불투명성에 대해서 아는대로 설명하시오. (107~108p)

- URI를 클라이언트 쪽에서 구성하거나 확장자로 리소스의 내용을 추단하거나 할 수 없는 특성을 URI는 클라이언트에 있어 불투명하다 라고 합니다.

17. 웹 서비스와 웹 API 설계에 있어서 URI가 중요한 이유 3가지는 무엇인가? (109p)

- URI는 리소스의 이름이다
- URI는 수명이 길다
- URI는 브라우저가 어드레스 란에 표시한다.

18. HTTP 메시지 구조를 그리고 각각에 대해서 설명하시오. (123~128p)

- 스타트라인 - 요청 메시지의 경우는 요청 라인, 응답 메시지의 경우는 스테이터스 라인이 된다.
- 헤더 - Content-Type헤더에서 HTML의 MIME 미디어 타입과 그문자 인코딩 방식을 지정
- 빈줄 - 헤더의 종료를 빈 줄로 식별한다.
- 바디 - HTML이 포함되어 있다.

19. 애플리케이션 상태란 무엇인가? 그리고 Stateful 서버의 결점은 무엇인가? (131~132p)

- 애플리케이션 상태란 세션 상태라고도 한다.
- 서버가 클라이언트의 상태를 기억하는 것은 클라이언트 수가 증가함에 따라 어려워지게 된다.

20. Self Descriptive Message가 무엇인지 설명하고 이를 이용한 Stateless 서버의 장점을 쓰시오. (132~134p)

- 요청을 처리하는 데 필요한 정보가 모두 포함되어 있는 메시지를 자기 기술적 메시지라고한다.

- 스테이트리스한 서버는 애플리케이션의 상태를 기억할 필요가 없기 때문에 서버 시스템이 단순해진다.

21. Stateless 서버의 단점은 무엇인가? (134~136p)

- 송신할 데이터의 양이 많아진다.

- 인증 등 서버에 부하가 걸리는 처리를 반복한다.

1. POST의 용도 3가지를 설명하시오. (141~145p)

- 서버 리소스의 작성
- 리소스에 데이터 추가
- 다른 메서드로는 대응할 수 없는 처리

2. 리소스 작성시 POST와 PUT 중에 POST를 쓰는게 적절한 이유는 무엇인가? (149p)

- POST는 클라이언트가 자동적으로 URI를 결정한다. PUT은 사용자가 직접 URI을 지정해야 한다. 그래서 웬만한 사이트가 아니면 POST를 사용한다.

3. HEAD의 사용 용도는 무엇인가? (151p)

- 리소스의 헤더만을 취득하는 메서드다. 이 성질을 이용하여 네트워크의 대역을 절약하면서 리소스의 크기를 조사하거나, 리소스의 갱신일자를 구할 수 있다.

4. 다음 요청과 응답의 의미는 각각 무엇인가? (152p)
   요청
   OPTIONS /list/item1 HTTP/1.1
   Host: Example.com

응답
HTTP/1.1 200 OK
Allow: GET, HEAD, PUT, DELETE

- 옵션 메소드는 그 리소스가 지원하고 있는 메서드가 무엇인지 요청하는 메소드다. 그래서 서버에서는 지원하는 메소드를 알려주고 있다.

5. 멱등성, 안전에 대해서 각각 설명하시오. (157p)

- 멱등성이란 어떤 조작을 몇 번을 해도 결과가 동일한 것을 말한다.
- 안전이란 조작 대상의 리소스의 상태를 변화시키지 않는 것.

6. 멱등성과 안전을 기준으로 GET, HEAD, PUT, DELETE, POST를 분류하시오. (158p)

- GET, HEAD는 멱등이고 안전하다
- PUT, DELETE는 멱등이지만 안전하지 않다.
- POST는 멱등이지도 안정하지도 않다.

7. GET을 바르게 이용하고 있는지 판단하는 기준은 무엇인가? (164p)

- GET을 실행 전후 리소스에 변경이 가해져있는 여부를 확인한다. 변경이 가해져 있으면 안된다.

8. 현재 토마토 가격은 100원이다. PUT으로 토마토 가격을 갱신할 때 다음 PUT 사용은 어떤 부분이 잘못됐는가? 또한 올바른 표현은 무엇인가? (165~167p)
   PUT /tomato HTTP/1.1
   Host: example.com
   Content-Type: text/plain; charset=utf-8

+50

- 멱등성이 깨져버린다.

9. 스테이터스 코드 1xx, 2xx, 3xx, 4xx, 5xx의 분류와 의미를 설명하시오. (173~174p)

- 1xx 처리중
- 2xx 성공
- 3xx 리다이렉트
- 4xx 클라이언트 에러
- 5xx 서버 에러

10. 스테이터스 코드에서 첫 번째 숫자를 이용한 분류 방식의 장점을 모두 설명하시오. (174~175p)

- 서버간의 약속을 최소한으로 억제하고 클라이언트와 서버의 결합을 가능한 한 완화하기 위해 즉 소결합을 위해 고안된 것이다.
  컴포넌트의 치환이나 확장이 용이해진다.

11. 다음 응답 코드의 문제점은 무엇인가? (189p)
    HTTP/1.1 200 OK
    Content-Type: application/xml

<error>
  <code>1001</code>
  <message>file not found</message>
</error>

- 바디에서 에러메시지를 출력하는데 응답은 성공을 띄워주고 있다.

12. HTTP에서 기술되는 일시는 어떤 표준시를 따르는가? (196p)

- GMT(존맛탱)

13. UTF-8로 선언된 xml 문서의 경우 Content-Type 헤더에 들어갈 알맞은 값은 무엇인가? (200~201p)

- Content-Type: application/xml; charset=UTF-8

14. Content Negotiation이란 무엇인가? (202p)

- 미디어 타입과 문자 인코딩, 언어 태그는 서버가 일방적으로 결정하는 것뿐만 아니라, 클라이언트와 교섭해서 정할 수 있다. 이방법을 콘텐트 네고시에이션이라고 한다.

15. 다음 2개의 메시지에 있는 10은 각각 몇 바이트인가? (205~206p)
    Content-Length: 10
    Transfer-Encoding: chunked
    Content-Type: Text/plain; charset=utf-8

10
The brow fox ju

- Content-Length은 10진수라서 그냥 10이고, 바디는 청크사이즈라서 16진수이기때문에 16이다.

16. WWW-Authenticate: Basic realm="Example.com 를 클라이언트 입장에서 해석하시오. (207~208p)

- WWW-Authenticate 헤더에 의해 클라이언트는 서버가 제공하는 인증 방식을 이해할 수 있게 되고, 그 방식에 따른 형식으로 인증 정보를 보낼 수 있다. 그리고 Basic인증을 지원하고 있다는 것을 알 수 있다. realm은 서버 상에서 이 리소스가 속한 URI의 공간의 이름이다.

17. URI Space를 설정하는 이유는 무엇인가? (208p)

- URI 스페이스는 URI에서 패스 이하를 가리키는 것이다.

- 클라이언트는 동일한 URI 공간에 속한 리소스에는 같은 인증 정보를 송싱할 수 있다고 가정하게 되어 있어, 요청을 보낼 때마다 매번 401가 반환되는 것을 피할 수 있다.

18. SSL/TLS에서 제공하는 3가지 기능에 대해서 설명하시오. (211p)

- 도청방지(암호화), 위조방지(변경 감지), 위장방지(인증)

19. Expires와 Cache-Control의 유효기간 표시법 차이는 무엇인가? (221p)

- Expires는 절대적시간으로 유효기간을 표시하나 Cashe-Control은 상대적으로 유효기간을 표시한다.

20. 조건부 GET If-Modified-Since 와 If-None-Match 은 어떻게 구분하여 사용하는가? (226p)

- ETag로 구분한다.

21. Pipelining이란 무엇인가? (227p)

- 지속적 접속에서는 클라이언트가 응답을 기다리지 않고 같은 서버에 요청을 송신할 수 있는데 이것을 파이프라인화라고 한다.

1. HTML이란 무엇인가? (232p)

- Hypertext Markup Language의 줄임말 하이퍼미디어를 구현하는 마크업 언어

2. 다음 문자 <, >의 실제 참조를 쓰시오. (239p)

- &if;, &gt;

3. 복수의 XML 포맷을 조합할 때 이름의 충돌을 방지할 목적으로 사용하는 것은 무엇인가? 그리고 선언하는 서식은 무엇인가? (241p)

- Namespace(이름 공간), 선언하는 서식은 xmlns:접두어 = '이름공간명'을 기술한다.

4. 다음 문서 URI는 http://example.com/test.html이다. <h1>을 가리키는 URI를 작성하시오. (251p)

<h1 id="title">첫 번째 HTML</h1>

- http://example.com/test.html#title

5. <a> <link>에 있는 rel 속성의 의미는 무엇인가? (257p)

- 링크하는 쪽과 링크되는 쪽의 리소스가 어떤 관계에 있는지를 기술한다.

6. 웹 서비스에서 JSON을 활용하는 이점은 무엇인가? (340p)

- JavaScript의 기법으로 데이터를 기술할 수 있는 점이 가장큰 특징. 매우 심플하다.

7. 크로스 도메인 통신 제한에 대해서 설명하고 이를 극복하는 2가지 해결법을 쓰시오. (348~350p)

- 불특정 다수의 도메인에 속하는 서버에 엑세스하는 것을 크로스 도메인이라고 한다.
- script요소에 의한 해결이나 콜백 함수를 활용하는 JSONP를 사용해서 해결한다.

8. JSON을 하이퍼미디어 포맷으로 사용할 때 중요한 점은 무엇인가? (353p)

- 다른 리소스와의 관계를 고려하여 링크를 확실히 넣는 설계를 하는 것이 중요하다.

9. 리소스를 설계할 때 가장 중요한 점은 무엇인가? (357p)

- 웹 서비스와 웹 API를 나눠서 생각하지 않는게 중요하다.

10. 리소스 지향 아키텍처의 설계 방법의 모든 단계를 설명하시오. (358p)

1) 웹 서비스에서 제공할 데이터를 특정한다.
2) 데이터를 리소스로 나눈다.
3) 리소스에 URI로 이름을 부여한다.
4) 클라이언트에 제공할 리소스의 표현을 설계한다.
5) 링크와 폼을 이용해 리소스와 리소스를 연결한다.
6) 이벤트의 표준적인 코스를 검토한다.
7) 에러에 대해 검토한다.

11. 리소스 지향 아키텍처의 4가지 특성은 무엇인가? 그리고 그 우선순위는? (360~361p)

- 어드레스 가능성 - URI만 있으면 리소스를 가리킬 수 있다는 성질
- 접속성 - 리소스를 링크로 접속하여 하나의 애플리케이션을 이룬다는 성질
- 유니폼 인터페이스 - URI로 지정한 리소스에 대한 조작을 가능하게 하는 아키텍처 스타일
- 스테이트리스성 - 서버에 클라이언트의 상태를 저장하지 않는 아키텍처 스타일

1. 리소스 작성에 POST 대신 PUT으로 작성한 경우의 장점과 단점을 모두 설명하시오. (397p)

장점

- POST를 지원할 필요가 없어지기 때문에 서버측의 구현이 간단해진다.
- 클라이언트가 작성과 변경을 구별할 필요가 없어도 되므로 구현이 간단해진다.

장점

- 클라이언트가 URI 구조를 미리 알아야 한다.
- 요청의 외관상으로는 그 조작이 신규작성인지 갱신인지 구별할 수 없다.

2. Bulk Update에 대해서 설명하고 장점과 단점을 설명하시오. (399p)

- 리소스 전체를 한번에 송시하는 갱신 방법을 벌크 업데이트라고 하며, 클라이언트의 구현이 간단해지는 반면에 전송할 데이터가 커진다는 단점이 있다.

3. 트랜잭션에 대하여 설명하시오. (406p)

- 양쪽 처리의 상태가 둘다 성공해야만 결과를 내놓는 것 한쪽만 성공했을 경우 원래 상태로 되돌린다.

4. RESTful한 설계를 지키려면 HTTP의 유니폼 인터페이스로 구현할 수 없는 처리를 만났을 때 어떻게 해야되는가? (407p)

- 새로운 리소스를 도입해 해결한다.

5. 베타제어란 무엇인가? (413p)

- 복수의 클라이언트가 동시에 하나의 리소스를 편집해 경합이 일어나지 않도록 하나의 클라이언트만 편집하도록 제어하는 처리를 말한다.

6. 비관적 잠금과 낙관적 잠금에 대해서 각각 설명하시오. (415~426p)

- 비관적 잠금이란 사용자가 잠금을 시작하면 그 사용자를 제외한 나머지 사용자들을 잠금 시키고, 잠금을 사용한 사용자만 편집할 수 있도록 하는 방식
- 낙관적 잠금이란 비관적 잠금과는 달리 문서 편집에 락을 걸지 않고 경합이 일어났을 때만 대처를 하는 구조다. 조건부 PUT과 조건부 DELETE를 이용한다.

7. 낙관적 잠금에서 Precondition Failed가 발생한 경우 3가지 대처법은 무엇인가? (428~429p)

- 경합을 일으킨 사용자에게 확인한 후, 갱신 또는 삭제를 한다.
- 경합을 일으킨 데이터를 경합 리소스로서 별도의 리소스로 보존한다.
- 경합을 일으킨 사용자에게 변경점을 전하고, 병합을 촉구한다.

8. 웹 서비스에서 제공할 데이터를 특정하고, 데이터를 리소스로 나누는 방법 3가지는 무엇인가? (432p)

- 관계 모델 ER 다이어그램
- 객체 지향 모델의 클래스 다이어그램
- 정보 아키텍처

9. 리소스 설계에서 굳이 정규화를 무너뜨리는 이유는 무엇인가? (435p)

- 하나하나의 리소스를 그 자체로 모든 것을 표현할 수 있도록 자기 기술적으로 만들기 위해 굳이 정규화를 무너뜨린다.

10. 객체지향 모델에서 리소스를 도출할 때 중요한 것은 무엇인가? (442p)

- 클래스가 가진 메서드를 조작결과 리스트로 반환하는 것.

11. 리소스를 설계할 때 가장 중요한 사고방식은? (449p)

- 웹 서비스와 웹API를 나누어서 생각하지 않는다.
