---
title: '일일 아티클 읽기'
date: 2022-01-01
tag: ['']
---

# 하루에 하나씩 아티클 읽기!

[jjuny 블로그](https://velog.io/@jjunyjjuny/%EC%9D%BC%EC%9D%BC-%EC%95%84%ED%8B%B0%ED%81%B4-6%EC%9B%94-now)에서 jjuny님이 하는거보고 재미있어보여서 시작했다...

## 2022년 6월

- 8월 8일 (월) [카카오웹툰은 CSS를 어떻게 작성하고 있을까?](https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/)

  - CSS-in-JS, CSS-Module의 차이점을 알아보고 어떤 특징을 가지고있는지 공부하다가 읽게되었음

  - 어떤 기술이든 서비스의 종류와 목적에 따라 적절한 기술을 사용해야한다.

  - 먼저 CSS-in-JS는 어떤 문제를 해결해주는가!!?

  1. class명이 빌드타임에 유니크하게 변경되기 때문에 별도의 명명 규칙이 필요치 않음

  2. CSS가 컴포넌트 단위로 추상화되기 때문에 CSS간 의존성 고려가 필요없다!

  3. 컴포넌트와 CSS가 동일한 파일내에 존재하기 때문에 수정 및 삭제가 용이하다!!(생산성이 높다!)

  4. 빌드 타임에 짧은 길이의 유니크한 클래스를 자동으로 생성하여 문서의 볼륨을 낮춰줌

  5. CSS 코드가 JS에 작성되므로 컴포넌트 상태 공유 가능(동적 CSS를 사용하기 좋다는 말 같음)

  6. CSS가 컴포넌트 스코프로 적용되므로 우선순위에 따른 문제가 없음.

  7. CSS가 컴포넌트에 격리되어 있기 때문에 상속 문제가 없음.

  - CSS-in-JS방식은 온전치 못하다. 그래서 많은 개발자들은 기존의 CSS 방식과 CSS Module 를 병행해서 사용한다. 테마 등의 공통 영역, 일부 유틸리티 등은 CSS-in-JS로 쉽게 해결이 어렵기 때문이다.

  - 또한 협업할때도 일반적으로 기존의 CSS 방식이나 CSS Module 방식이 좋다. 만약! 마크업 개발자가 있다면 CSS-in-JS 방식은 불편할 수 있다. 왜냐하면 마크업 개발자는 페이지 단위로 작업하고, 프론트엔드 개발자는 컴포넌트 단위로 작업하기 때문이다. 또한 CSS Module 방식도 컴포넌트 단위로 추상화가 가능하다

  - 일반적으로 CSS Module 방식은 빌드타임에 온전한 CSS파일로 변환되므로 자바스크립트와 같이 변환이 필요한 CSS-in-JS 보다 속도가 빠르다.

  - 카카오웹툰은 CSS Module로 시작했다가 디자이너와 협업이 필요한 상황, 애매모호한 상황이 많아지자 테일윈드(확장성 있는 부트스트랩(?))를 적용했다.

  - 기존의 부트스트랩과는 다르게 확장성이 좋다. 필요에따라 CSS를 변경할 수 있다.

  - 테일윈드는 사용하지 않는 클래스가 제거되어 번들 크기가 줄어드는 장점이 있다.

  - 테일윈드는 rem 단위가 기본이기 때문에 px 단위 서비스라면 기본값을 바꿔줘야한다.

  - 빌드 타임에 모두 생성되므로 동적 변수를 사용할 수없다.
    애니메이션과 트랜지션 사용에 제약이 있다. 그래서 미리 만들어진 애니메이션만 제공하기 때문에 필요한 애니메이션을 추가해야 한다.

- 8월 9일 (화) [Webpack 빌드에 날개를 달아줄 Esbuild-Loader](https://fe-developers.kakaoent.com/2022/220630-four-ways-web-animation/)

  - 요즘 웹팩을 공부중인데, 흥미롭게 읽었음 다음 프로젝트는 ESbuild를 사용해봐야겠다.
  - 웹팩은 프론트엔드 개발 환경에서 주로 사용되고 있는 모듈 번들러다. 웹팩은 기본적으로 자바스크립트 리소스만 읽고 처리할 수 있다. HTML, CSS, Image, Font와 같은 리소스도 모듈로 처리될수 있도록 하려면 별도의 전처리기가 필요하다. 이과정을 수행해주는 것이 로더다.
  - 브라우저가 최신 자바스크립트 스펙을 따라오지 못하기 때문에 babel을 통해 낮은 버전의 자바스크립트로 트랜스파일을 거쳐서 실행된다. 웹팩에서 Babel-Loader로 설정한다.
  - Webpack은 코드 한부분이 수정되면 다시 의존성 그래프를 구성하고, 리빌딩하는 과정을 거치고, Babel-Loader 전처리과정을 다시 수행하기 때문에 비효율적이다.
  - ESbuild-Loader을 사용해서 빌드한 것이 Babel-Loader을 사용한것보다 속도가 2배나 빠른것으로 보인다.Esbuild가 빠른이유는 Go언어로 작성된 모듈 번들러이기 떄문이다. 기본적으로 자바스크립트와 Go언어 자체에서 퍼포먼스 차이가 발생한다. 자바스크립트는 인터프리터 언어이기 때문에 한줄한줄 인터프리터가 기계어로 변환하는 반면 Go는 프로그램 실행 전 컴파일 단계에서 미리 소스코드를 전부 기계어로 변환해놓기 때문에 속도에서 차이가 발생한다.
  - 다중작업 능력에서도 차이가 발생한다. 자바스크립트는 싱글스레드라서 한번에 한파일씩 번들링하는 반면 Go는 공유 메모리 환경 아래에서 멀티 스레드 기반으로 동작한다. 즉 여러 파일이 동시에 번들링 된다.

- 8월 10일 (수) [웹 애니메이션을 구현하는 4가지 방법](https://fe-developers.kakaoent.com/2022/220630-four-ways-web-animation/)

  - 자바스크립트 애니메이션, CSS 애니메이션에 관심이 있었는데 재미있게 읽었음
  - CSS transition은 가장 많이 쓰이는 방식이다 단순한 클릭으로 요소의 위치나 크기를 변경할 떄 유용하다. CSS animation 방식은 transition과 용도가 조금 다르다. 여러 효과를 혼합하거나 연쇄적 동작처럼 더 복잡한 인터렉션을 구현할 때 사용한다. 코드 자체는 transition과 복잡해질뿐 방법은 크게 다르지 다르지 않다.
  - SVG animaion은 2차원 벡터 그래픽을 표현하기 위한 XML 마크업 언어다. SVG는 JPEG나 PNG에 비해 다음과 같은 장점이 있다.
    - W3C 표준과 호환되기 때문에, HTML 문서에 그대로 사용할 수 있습니다.
    - 대체로 JPEG, PNG에 비해 용량이 작습니다.
    - 확대하더라도 꺠짐 없이 선명하게 보입니다.
  - SVG는 웹표준에 호환되기 떄문에 모든 브라우저에서 동작하지만 animateTransform 이라는 요소는 크롬이나 파이어폭스 같은 브라우저에서는 정상 동작하지만, 이외 브라우저는 확인이 필요하다.
  - 마지막으로 Animation API입니다. JS로 애니메이션을 구혀하기 떄문에 자유도가 높아서 복잡한 인터렉션도 가능합니다. JS 변수를 활용하거나 함수를 만들어 재사용하기도 편하다. 음.. 이부분은 직접 써봐야 이해할 것 같다.

- 8월 11일 (목) [사용자 경험과 성능 개선 방법 in 카카오 웹툰](https://fe-developers.kakaoent.com/2022/220120-ux-and-perf-in-kakaowebtoon/)
- 제목이 흥미로워서 읽었지만 양질의 정보가 있는 글이였음..
- CDN은 콘텐츠를 캐싱하여 사용자가 어디서 접속하던지 빠르게 전송해준다. 실제 서버에 부하도 거의 주지 않고, 서버의 위치와 상관없이 전 세계에서 서비스를 할 수 있다. 요즘 많은 클라우드 서비스들에서도 손쉽게 사용할 수 있도록 제공한다. 클로벌로 서비스를하는 카카오웹툰도 웹에서 보이는 수많은 리소스들을 CDN을 통해 제공하고 있다. 만약 콘텐츠가 변하지 않는다면, 정적 페이지로 만들어 리소스처럼 CDN을 통해 빠르게 제공할 수 있다. 하지만 사용자마다 달라지는 추천 영역이나 운영 또는 시간의 흐름에 따라 언제든 변경될 수 있는 페이지가 있다면, 그리고 이러한 페이지들이 중요도가 높아서 첫 진입시 빠르게 보여주기 위한 것과, 검색엔진 SEO가 필요하기 떄문에 Next.js를 사용해서 SSR을 사용하고있다.
- SSR로 첫 진입시 완성된 페이지를 제공한다는 장점이 생겼지만, 매 요청 마다 렌더링이라는 비용이 추가로 발생한다. 이를 위해 SSR 결과에 캐싱을 적용했다. 데이터의 변경이 실시간으로 반영될 필요가 없고, 동일한 요청이 빈번한 페지이들의 경우 SSR 결과를 캐싱해두고 일정시간마다 갱신하면서 재사용 하고 있다. 처음에는 요청이 오면 해당 캐시가 만료되었다면 바로 무효화하고 다시 렌더링을 해서 캐싱과 응답을 주도록 했는데, 이런 방법은 렌더링을 발생시킨 요청을 포함해 완료 전까지 들어온 요청들은 그만큼 지연이 발생된다.
- 그러나 SEO가 필요없고, 첫 진입시 보이는 영역을 곧바로 보여주지 않아도 된다면 해당 영역을 제외하고 정적페이지로 만들어 브라우저에서 갱신하도록 하는 것도 하나의 방법이다.
- 로딩이 존재한다면 Loading Shimmer(Skeleton 혹은 Placeholder)를 사용하여 자연 스러운 페이지 전환을 구현할 수 있다. 그렇다고 모든 영역에 적용해야 하는 것은 아니다. 필요한 화면에서 오래 걸릴 수 있는 작업에만 적용하고, 콘텐츠의 로드를 방해하지 않는 선에서 사용해야한다. 만약 React를 사용한다면 Suspense 컴포넌트 사용을 고려해보자[Suspense와 선언적으로 Data fetching](https://fe-developers.kakaoent.com/2021/211127-211209-suspense/)
- CDN을 통해 리소스를 제공하는 것과 더불어 최적화된 리소스를 사용하는 것도 중요하다. 더 적은 용량의 리소스를 사용하면 그만큼 더 빠르게 전송할 수 있다. 카웹의 경우는 이미지 요소는 SVG를 사용했지만 벡터이미지가 모든 경우에 효과적이지 않다. 그래서 WebP와 이전 버전의 safari 처럼 WebP를 지원하지 않는 브라우저를 위해 PNG를 함께 사용한다. 예를들면 <picture>를 사용하면 간단히 브라우저가 지원하는 이미지 포맷을 선택해 사용할 수 있다. 이미지를 사용할 때 마다 서버에서 제공되는 포맷들을 안다면 이를 이미지 네이밍 규칙을 통해서 처리할 수 있다. 영상에 경우 비슷한 방법을 사용한다.
- CDN을 통해 최적화된 리소스를 제공해도 한번에 많은 양을 내려받는다면 그 효과는 미미하다. 사용자는 보고있는 화면이 얼마나 빠르게 표시되는지가 중요하기 때문에 이와 무관한 영역의 리소스를 먼저 받으면 느리다고 인식한다. 또한 해당 리소스를 사용하기 전에 전환이 발생한다면 불필요한 리소스를 받는 상황이 생길 수 있다.
  따라서 lazy loading을 통해서 최초에는 ATF (Above-The-Fold)에 포함된 리소스를 먼저 내려받로고 하고, 인터렉션이나 전환 시에는 그때마다 필요한 리소스를 미리 받아서 보여주도록 하는게 좋다.[하드웨어 가속과 intersectionObserver](https://fe-developers.kakaoent.com/2021/211202-gpu-intersection-observer/)
- requestAnimationFrame()을 사용하면 프레임 생성 시작에 맞춰 자바스크립트가 실행되기 떄문에 프레임 누락이 없는 부드러운 애니메이션 표현이 가능하다.
- ## 터치나 휠 괕은 이벤트 리스너가 등록되어 있다면 preventDefault() 호출을 통해 기본 동작인 스크롤을 막을 가능성이 있다. 그래서 컴포지터는 바로 합성을 하지 않고 메인 스레드로부터 해당 정보가 올 때까지 기다리게된다. passive옵션을 사용하면 해당 리스너에서 preventDefault()를 호출하지 않을 것이라고 판단하고 스크롤 시 바로 화면을 합성하고 부드러운 스크롤이 동작한다.하지만 모든 브라우저에 적용이 안될뿐더러 크롬, 파이어 폭스는 기본값이 true라서 반대의 경우에는 false로 설정한다.

- 8월 12일 (금) [Mitakes | 주니어 리액트 개발자인 내가 실수하고 있었던 것](https://velog.io/@edie_ko/Mistakes-%EC%A3%BC%EB%8B%88%EC%96%B4-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%B8-%EB%82%B4%EA%B0%80-%EC%8B%A4%EC%88%98%ED%95%98%EA%B3%A0-%EC%9E%88%EC%97%88%EB%8D%98-%EA%B2%83)

  - 제목부터가 재미있어 보여서 읽었다.
  - 새로운 상태는 이전 상태에 기반한 setState를 만들어서 업데이트 해야한다. setState는 비동기적으로 작동을 하기때문에 상태값을 batch(일정 시간 동안 변화하는 상태를 일괄 처리)로 변경하기 때문이다.

  ```tsx
  const [isState, setState] = useState(false)
  const toggleBtn = () => setState(!isState) // x
  const toggleBtn = () => setState(isState => !isState) // o
  ```

  - 상태 객체 얇은복사 주의해야함
  - value가 undefined나 null인 경우 OP operator을 많이 사용하는데 주의해야한다. 0도 결국 undefined, false와 같다.
  - JSON mock data 만들때 JSON.stringify써서 편하게 복사가 가능하다
  - 컴포넌트에 전달하는 props가 true일 경우 따로 true를 표시하지 않는다.
  - 비동기처리 병목현상 Promise.all, Promise.allSettled 사용하기
  - 삼항 연산자 쓰기보단 미리 조건문으로 리턴해주기

  - 8월 14일 (금) [웹사이트 최적화 방법](https://oliveyoung.tech/blog/2021-11-22/How-to-Improve-Web-Performance-with-Image-Optimization/)

  - 최적화에 관심이 많았는데 제목부터가 흥미를 끄는 글이라 읽었다.
  - 디지털 이미지는 일반적으로 브라우저에서 어떻게 렌더링 되느냐에 따라 레스터 이미지 타입과 벡터 이미지 타입, 그리고 이미지 손실을 어느 정도 허용하는지에 따라, 무손실 이미지 타입과 손실 이미지 타입으로 구분된다.
  - 레스터 이미지는 흔히 아는 픽셀에 표현하고자 하는 색상을 그려서 이미지 형태로 표현하는 방식, 주로 개발자들이 사용하는 JPEG, PNG, GIF가 있으며, 여러 픽셀이 모여서 하나의 이미지를 만들기 떄문에 사이즈가 크거나 품질이 좋은 이미지를 만들기 위해서는 그만큼 정보를 담은 픽셀을 추가해야 하기 떄문에, 사이즈가 커지면 커질수록, 이미지의 용량도 늘어나고, 렌더링 속도도 현저히 떨어진다.
  - 벡터 이미지는 픽셀값으로 그리는게 아닌 이미지 안에 수많은 수학적 방정식을 퐇마하고 있는 이미지 형태다. 그래서 사이즈가 커지거나 작아져도 이미지가 깨지거나 정보가 달라지지 않는다. 즉 항상 같은 이미지 품질을 유지할 수 있다. 하지만 이미지가 복잡하면 복잡할 수록 수학적 정보는 계속 늘어나고, 이미지 용량 또한 같이 늘난다. 주로 아이콘, 폰트에 사용
  - 무손실 이미지는 원본 이미지에서 이미지를 렌더링하는데 필요하지 않은 정보들을 제거한 이미지를 말한다. 따라서 무손실 이미지는 원본 이미지보다 용량이 줄어들 수 있다. 예를들면 GIF,PNG가 있다.
  - 손실 이미지는 무손실 이미지의 화질을 감수하면서도 사이즈를 줄여 빠른 렌더링할 수 있는 이미지다. 일반적으로 사람이 품질 저하를 눈치채지 못하면서 낮을수 있는 퍼센트는 100% ~ 75%다. 페이스북은 85% 손실 이미지를 사용한다. 손실 이미지는 무손실 이미지보다 빠른 렌더링 가능, 꼭 필요한 이미지가 아닌 경우 사용 대표적으로 JPEG
  - WebP는 구글에서 개발한 이미지 포맷, 손실 압축과 비손실 압축을 모두 지원한다. 25% ~ 35% 압축이 가능한 이미지 포맷이다. 또한 투명, 애니메이션 기능을 제공하므로 GIF, PNG, JPEG 등의 상용 이미지 포맷을 대체할 수 있다. 하지만 디바이스 사양에 따라서 상용 이미지 포맷보다 더 높은 리소스 필요, IE를 지원X,Progressive Image 지원X라는 단점이 있다.
  - AVIF은 WebP와 마찬가지로 GIF, PNG, JPEG등의 상용 이미지 포맷을 대체할 수 있다.. 또한 애니메이션기능이 있고, 압축 효율이 WebP보다 뛰어나지만, 최신 포맷이기 때문에 AVIF를 지원하는 뷰어가 적고, 브라우저 지원율이 낮다는 단점이 있다.또한 단순한 패턴의 이미지를 압축하는 경우 PNG보다 낮은 압축률을 보인다.
  - 데스크톱과 모바일의 이미지 용량은 다를수밖에없다. 그렇기 때문에 사용자는 필요 이상의 이미지를 다운받기 때문에 리소스가 낭비된다. 그러므로 <img> 태그의 srcset속성, <picture> 태그를 사용해서 브라우저 사이즈에 맞게 브레이크 포인트를 걸어 과도한 리소스를 사용하지 못하게 하는 방법이 있다.
  - 웹사이트의 이미지는 최대한 사용자가 보이는 부분부터 로드되도록 처리하며, 사용자가 보이지 않는 부분은 Lazy Loading을 적용하여 사용자 경험 저하를 막을 수 있다. 즉 사용자가 보이는 부분만 로드함으로써 로딩 시간을 줄일 수 있다.
  - 이미지 CDN은 이미지 변환, 최적화 및 전송을 담당하는 서버로, 이미지 CDN을 사용하면 이미지 다운로드 속도를 40%~80%로 줄일수 있습니다. 또한 Image CDN에서 로드된 이미지의 경우 이미지 URL에 따라 다양한 이미지를 요청할 수 있다. 또한 HTTP 캐시를 이용한 이미지 캐싱이 가능하다. 물론 CDN을 활요한 캐시는 적절한 캐시정책이 필요하다.
  - CSS image Sprite는 여러 개의 이미지를 합친 하나의 이미지 셋을 말한다. 첫 페이지 로딩 속도를 줄여주는 가장 대표적인 방법이다. 실제로 10번의 이미지 요청을 1번의 요청으로 해결할 수 있으며, 대표적으로 아이콘이나 버튼 같은 이미지들을 하나로 합쳐 배경 이미지를 만들어 놓고 position 값으로 각각의 이미지들을 잘라서 사용하는 방식이다.

- 8월 16일 (금) [누구나 원하는 개발자되기](https://blog.shiren.dev/2020-11-23/)
- 나에게 필요한 내용같아서 읽었다.
- 주요 역량 항목
  - 어떤 프로젝트를 경험했는지
  - 어떤 도구/프레임워크를 사용했는지
  - 어떤 개발 방법론을 사용했는지
  - 프로젝트에 어떤 책임으로 참여했는지 개발자인지 개발리더인지
  - 팀이나 회사에 프로젝트외에 어떤 기여를 했는지
  - 프로젝트에서 발생한 기술적인 문제를 어떻게 해결하는지
  - 리더쉽, 협업, 커뮤니케이션 스킬
- 이력서를 주기적으로 업데이트하면서 반서과 동기부여를 가지는 시간을 갖자.
- 단순히 경험을 적기보다는 역량을 어필할 수 있는 포인트를 하나 이상 적자.
- 단순 기술 보다는 "성과"라는 스토리를 담으려고 노력하자!
  - 효율적인 기술들을 검토해서 스택을 결정하고 팀에 전파
  - 난이도가 높은 기술을 사용했거나 직접 개발 했던 경험
  - 개발 환경이나 구조를 구축
  - 레거시 코드를 포팅하거나 새로운 코드로 교체
  - 월등한 성능 개선
  - 익숙하지만 노후된 프레임워크를 본인의 설파와 계몽을 통해 새로운 프레임워크로 변경
  - 본인이 개발한 모듈에 대한 자랑거리(성능, 적은 코드, 구조, 가독성) 등등..
- 사전과제 코딩테스트
  - 효율적인 구조
  - 컴포넌트나 모듈의 책임과 역할
  - 코드의 일관성, 가독성, 유지보수성
  - 변수, 함수, 클래스등의 네이밍
  - 안티 패턴에 대한 이해
  - 성능에 대한 이해
  - 모던 개발 환경에 대한 이해
- 정상 동작은 기본이고, 꼭 하고 싶었던 것 을 20%정도만 첨가해보자
- 로깅 코드나 주석, 필요없는 코드를 제거하자
- node_modules와 빌드 결과물은 제거하고 제출하자 package.json, 환경 설정파일, 코드만 제출하는게 좋다
- 면접
  - 사용한 프레임워크에 대해서 기술적인 질문에 답을 할 수 있어야한다.
  - 자신있는 기술일수록 더 잘 준비해서 설명하자.
  - 괜히 모르는 것을 설명하려고 하지말자.
- 과정을 어필해라 내가 무엇을 경험하고 무엇을 배웠는지

* 8월 17일 (금) [신입 프론트엔드 개발자를 위한 면접 조언](https://taegon.kim/archives/5770)
  - 신입은 어마어마한 기술적 소양을 물어보기보다는 다루는 기술의 기본을 충실히 알고 있는게 중요하다. 본인이 잘 안다고 생각하는 것들을 다시 확인해보자
  - 처음부터 끝까지 잘 설명할 수 있는지 스스로 확인해보자.
  - 포트폴리오는 가능하면 GitHub같은 호스팅 서비스에 올려두자.
  - .gitignore파일에 .idea 폴더나 npm-debug.log 같은 불필요한 파일은 포함되지 않게 설정하자.
  - 커밋 메시지는 의외로 많은 것을 말해준다. 신경써서 작성하자.
  - 포트폴리오 쓸 때 기술은 나열 하되 강조는 하지않는게 좋다.
  - 테스트 케이스는 성의껏 작성하자. 좋은 인상을 줄 수 있다.

- 8월 18일 (금) [고무오리 문제 해결 방법](https://wikibook.co.kr/article/rubber-duck-problem-solving/)
-
