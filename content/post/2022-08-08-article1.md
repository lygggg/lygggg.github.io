---
title: '일일 아티클 읽기'
date: 2022-01-01
tag: ['']
---

# 하루에 하나씩 아티클 읽기!

[jjuny 블로그](https://velog.io/@jjunyjjuny/%EC%9D%BC%EC%9D%BC-%EC%95%84%ED%8B%B0%ED%81%B4-6%EC%9B%94-now)에서 jjuny님이 하는거보고 재미있어보여서 시작했다...

## 2022년 6월

- 8월 8일 (월) [카카오웹툰은 CSS를 어떻게 작성하고 있을까?](https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/)

  - CSS-in-JS, CSS-Module의 차이점을 알아보고 어떤 특징을 가지고있는지 공부하다가 읽게되었음

  - 어떤 기술이든 서비스의 종류와 목적에 따라 적절한 기술을 사용해야한다.

  - 먼저 CSS-in-JS는 어떤 문제를 해결해주는가!!?

  1. class명이 빌드타임에 유니크하게 변경되기 때문에 별도의 명명 규칙이 필요치 않음

  2. CSS가 컴포넌트 단위로 추상화되기 때문에 CSS간 의존성 고려가 필요없다!

  3. 컴포넌트와 CSS가 동일한 파일내에 존재하기 때문에 수정 및 삭제가 용이하다!!(생산성이 높다!)

  4. 빌드 타임에 짧은 길이의 유니크한 클래스를 자동으로 생성하여 문서의 볼륨을 낮춰줌

  5. CSS 코드가 JS에 작성되므로 컴포넌트 상태 공유 가능(동적 CSS를 사용하기 좋다는 말 같음)

  6. CSS가 컴포넌트 스코프로 적용되므로 우선순위에 따른 문제가 없음.

  7. CSS가 컴포넌트에 격리되어 있기 때문에 상속 문제가 없음.

  - CSS-in-JS방식은 온전치 못하다. 그래서 많은 개발자들은 기존의 CSS 방식과 CSS Module 를 병행해서 사용한다. 테마 등의 공통 영역, 일부 유틸리티 등은 CSS-in-JS로 쉽게 해결이 어렵기 때문이다.

  - 또한 협업할때도 일반적으로 기존의 CSS 방식이나 CSS Module 방식이 좋다. 만약! 마크업 개발자가 있다면 CSS-in-JS 방식은 불편할 수 있다. 왜냐하면 마크업 개발자는 페이지 단위로 작업하고, 프론트엔드 개발자는 컴포넌트 단위로 작업하기 때문이다. 또한 CSS Module 방식도 컴포넌트 단위로 추상화가 가능하다

  - 일반적으로 CSS Module 방식은 빌드타임에 온전한 CSS파일로 변환되므로 자바스크립트와 같이 변환이 필요한 CSS-in-JS 보다 속도가 빠르다.

  - 카카오웹툰은 CSS Module로 시작했다가 디자이너와 협업이 필요한 상황, 애매모호한 상황이 많아지자 테일윈드(확장성 있는 부트스트랩(?))를 적용했다.

  - 기존의 부트스트랩과는 다르게 확장성이 좋다. 필요에따라 CSS를 변경할 수 있다.

  - 테일윈드는 사용하지 않는 클래스가 제거되어 번들 크기가 줄어드는 장점이 있다.

  - 테일윈드는 rem 단위가 기본이기 때문에 px 단위 서비스라면 기본값을 바꿔줘야한다.

  - 빌드 타임에 모두 생성되므로 동적 변수를 사용할 수없다.
    애니메이션과 트랜지션 사용에 제약이 있다. 그래서 미리 만들어진 애니메이션만 제공하기 때문에 필요한 애니메이션을 추가해야 한다.

- 8월 9일 (화) [Webpack 빌드에 날개를 달아줄 Esbuild-Loader](https://fe-developers.kakaoent.com/2022/220630-four-ways-web-animation/)

  - 요즘 웹팩을 공부중인데, 흥미롭게 읽었음 다음 프로젝트는 ESbuild를 사용해봐야겠다.
  - 웹팩은 프론트엔드 개발 환경에서 주로 사용되고 있는 모듈 번들러다. 웹팩은 기본적으로 자바스크립트 리소스만 읽고 처리할 수 있다. HTML, CSS, Image, Font와 같은 리소스도 모듈로 처리될수 있도록 하려면 별도의 전처리기가 필요하다. 이과정을 수행해주는 것이 로더다.
  - 브라우저가 최신 자바스크립트 스펙을 따라오지 못하기 때문에 babel을 통해 낮은 버전의 자바스크립트로 트랜스파일을 거쳐서 실행된다. 웹팩에서 Babel-Loader로 설정한다.
  - Webpack은 코드 한부분이 수정되면 다시 의존성 그래프를 구성하고, 리빌딩하는 과정을 거치고, Babel-Loader 전처리과정을 다시 수행하기 때문에 비효율적이다.
  - ESbuild-Loader을 사용해서 빌드한 것이 Babel-Loader을 사용한것보다 속도가 2배나 빠른것으로 보인다.Esbuild가 빠른이유는 Go언어로 작성된 모듈 번들러이기 떄문이다. 기본적으로 자바스크립트와 Go언어 자체에서 퍼포먼스 차이가 발생한다. 자바스크립트는 인터프리터 언어이기 때문에 한줄한줄 인터프리터가 기계어로 변환하는 반면 Go는 프로그램 실행 전 컴파일 단계에서 미리 소스코드를 전부 기계어로 변환해놓기 때문에 속도에서 차이가 발생한다.
  - 다중작업 능력에서도 차이가 발생한다. 자바스크립트는 싱글스레드라서 한번에 한파일씩 번들링하는 반면 Go는 공유 메모리 환경 아래에서 멀티 스레드 기반으로 동작한다. 즉 여러 파일이 동시에 번들링 된다.

- 8월 10일 (수) [웹 애니메이션을 구현하는 4가지 방법](https://fe-developers.kakaoent.com/2022/220630-four-ways-web-animation/)

  - 자바스크립트 애니메이션, CSS 애니메이션에 관심이 있었는데 재미있게 읽었음
  - CSS transition은 가장 많이 쓰이는 방식이다 단순한 클릭으로 요소의 위치나 크기를 변경할 떄 유용하다. CSS animation 방식은 transition과 용도가 조금 다르다. 여러 효과를 혼합하거나 연쇄적 동작처럼 더 복잡한 인터렉션을 구현할 때 사용한다. 코드 자체는 transition과 복잡해질뿐 방법은 크게 다르지 다르지 않다.
  - SVG animaion은 2차원 벡터 그래픽을 표현하기 위한 XML 마크업 언어다. SVG는 JPEG나 PNG에 비해 다음과 같은 장점이 있다.
    - W3C 표준과 호환되기 때문에, HTML 문서에 그대로 사용할 수 있습니다.
    - 대체로 JPEG, PNG에 비해 용량이 작습니다.
    - 확대하더라도 꺠짐 없이 선명하게 보입니다.
  - SVG는 웹표준에 호환되기 떄문에 모든 브라우저에서 동작하지만 animateTransform 이라는 요소는 크롬이나 파이어폭스 같은 브라우저에서는 정상 동작하지만, 이외 브라우저는 확인이 필요하다.
  - 마지막으로 Animation API입니다. JS로 애니메이션을 구혀하기 떄문에 자유도가 높아서 복잡한 인터렉션도 가능합니다. JS 변수를 활용하거나 함수를 만들어 재사용하기도 편하다. 음.. 이부분은 직접 써봐야 이해할 것 같다.

- 8월 11일 (목) [사용자 경험과 성능 개선 방법 in 카카오 웹툰](https://fe-developers.kakaoent.com/2022/220120-ux-and-perf-in-kakaowebtoon/)
- 제목이 흥미로워서 읽었지만 양질의 정보가 있는 글이였음..
- CDN은 콘텐츠를 캐싱하여 사용자가 어디서 접속하던지 빠르게 전송해준다. 실제 서버에 부하도 거의 주지 않고, 서버의 위치와 상관없이 전 세계에서 서비스를 할 수 있다. 요즘 많은 클라우드 서비스들에서도 손쉽게 사용할 수 있도록 제공한다. 클로벌로 서비스를하는 카카오웹툰도 웹에서 보이는 수많은 리소스들을 CDN을 통해 제공하고 있다. 만약 콘텐츠가 변하지 않는다면, 정적 페이지로 만들어 리소스처럼 CDN을 통해 빠르게 제공할 수 있다. 하지만 사용자마다 달라지는 추천 영역이나 운영 또는 시간의 흐름에 따라 언제든 변경될 수 있는 페이지가 있다면, 그리고 이러한 페이지들이 중요도가 높아서 첫 진입시 빠르게 보여주기 위한 것과, 검색엔진 SEO가 필요하기 떄문에 Next.js를 사용해서 SSR을 사용하고있다.
- SSR로 첫 진입시 완성된 페이지를 제공한다는 장점이 생겼지만, 매 요청 마다 렌더링이라는 비용이 추가로 발생한다. 이를 위해 SSR 결과에 캐싱을 적용했다. 데이터의 변경이 실시간으로 반영될 필요가 없고, 동일한 요청이 빈번한 페지이들의 경우 SSR 결과를 캐싱해두고 일정시간마다 갱신하면서 재사용 하고 있다. 처음에는 요청이 오면 해당 캐시가 만료되었다면 바로 무효화하고 다시 렌더링을 해서 캐싱과 응답을 주도록 했는데, 이런 방법은 렌더링을 발생시킨 요청을 포함해 완료 전까지 들어온 요청들은 그만큼 지연이 발생된다.
- 그러나 SEO가 필요없고, 첫 진입시 보이는 영역을 곧바로 보여주지 않아도 된다면 해당 영역을 제외하고 정적페이지로 만들어 브라우저에서 갱신하도록 하는 것도 하나의 방법이다.
- 로딩이 존재한다면 Loading Shimmer(Skeleton 혹은 Placeholder)를 사용하여 자연 스러운 페이지 전환을 구현할 수 있다. 그렇다고 모든 영역에 적용해야 하는 것은 아니다. 필요한 화면에서 오래 걸릴 수 있는 작업에만 적용하고, 콘텐츠의 로드를 방해하지 않는 선에서 사용해야한다. 만약 React를 사용한다면 Suspense 컴포넌트 사용을 고려해보자[Suspense와 선언적으로 Data fetching](https://fe-developers.kakaoent.com/2021/211127-211209-suspense/)
- CDN을 통해 리소스를 제공하는 것과 더불어 최적화된 리소스를 사용하는 것도 중요하다. 더 적은 용량의 리소스를 사용하면 그만큼 더 빠르게 전송할 수 있다. 카웹의 경우는 이미지 요소는 SVG를 사용했지만 벡터이미지가 모든 경우에 효과적이지 않다. 그래서 WebP와 이전 버전의 safari 처럼 WebP를 지원하지 않는 브라우저를 위해 PNG를 함께 사용한다. 예를들면 <picture>를 사용하면 간단히 브라우저가 지원하는 이미지 포맷을 선택해 사용할 수 있다. 이미지를 사용할 때 마다 서버에서 제공되는 포맷들을 안다면 이를 이미지 네이밍 규칙을 통해서 처리할 수 있다. 영상에 경우 비슷한 방법을 사용한다.
- CDN을 통해 최적화된 리소스를 제공해도 한번에 많은 양을 내려받는다면 그 효과는 미미하다. 사용자는 보고있는 화면이 얼마나 빠르게 표시되는지가 중요하기 때문에 이와 무관한 영역의 리소스를 먼저 받으면 느리다고 인식한다. 또한 해당 리소스를 사용하기 전에 전환이 발생한다면 불필요한 리소스를 받는 상황이 생길 수 있다.
  따라서 lazy loading을 통해서 최초에는 ATF (Above-The-Fold)에 포함된 리소스를 먼저 내려받로고 하고, 인터렉션이나 전환 시에는 그때마다 필요한 리소스를 미리 받아서 보여주도록 하는게 좋다.[하드웨어 가속과 intersectionObserver](https://fe-developers.kakaoent.com/2021/211202-gpu-intersection-observer/)
- requestAnimationFrame()을 사용하면 프레임 생성 시작에 맞춰 자바스크립트가 실행되기 떄문에 프레임 누락이 없는 부드러운 애니메이션 표현이 가능하다.
- ## 터치나 휠 괕은 이벤트 리스너가 등록되어 있다면 preventDefault() 호출을 통해 기본 동작인 스크롤을 막을 가능성이 있다. 그래서 컴포지터는 바로 합성을 하지 않고 메인 스레드로부터 해당 정보가 올 때까지 기다리게된다. passive옵션을 사용하면 해당 리스너에서 preventDefault()를 호출하지 않을 것이라고 판단하고 스크롤 시 바로 화면을 합성하고 부드러운 스크롤이 동작한다.하지만 모든 브라우저에 적용이 안될뿐더러 크롬, 파이어 폭스는 기본값이 true라서 반대의 경우에는 false로 설정한다.

- 8월 12일 (금) [Mitakes | 주니어 리액트 개발자인 내가 실수하고 있었던 것](https://velog.io/@edie_ko/Mistakes-%EC%A3%BC%EB%8B%88%EC%96%B4-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%B8-%EB%82%B4%EA%B0%80-%EC%8B%A4%EC%88%98%ED%95%98%EA%B3%A0-%EC%9E%88%EC%97%88%EB%8D%98-%EA%B2%83)
  - 제목부터가 재미있어 보여서 읽었다.
  - 새로운 상태는 이전 상태에 기반한 setState를 만들어서 업데이트 해야한다. setState는 비동기적으로 작동을 하기때문에 상태값을 batch(일정 시간 동안 변화하는 상태를 일괄 처리)로 변경하기 때문이다.
  ```tsx
  const [isState, setState] = useState(false)
  const toggleBtn = () => setState(!isState) // x
  const toggleBtn = () => setState(isState => !isState) // o
  ```
  - 상태 객체 얇은복사 주의해야함
  - value가 undefined나 null인 경우 OP operator을 많이 사용하는데 주의해야한다. 0도 결국 undefined, false와 같다.
  - JSON mock data 만들때 JSON.stringify써서 편하게 복사가 가능하다
  - 컴포넌트에 전달하는 props가 true일 경우 따로 true를 표시하지 않는다.
  - 비동기처리 병목현상 Promise.all, Promise.allSettled 사용하기
  - 삼항 연산자 쓰기보단 미리 조건문으로 리턴해주기
    https://oliveyoung.tech/blog/2021-11-22/How-to-Improve-Web-Performance-with-Image-Optimization/ 내일 이거봐라
