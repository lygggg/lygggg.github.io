{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019-12-29-study2/","result":{"data":{"markdownRemark":{"html":"<h2>Chapter06</h2>\n<h2>HTTP의 기본</h2>\n<h3>HTTP의 중요성</h3>\n<p>HTTP란?</p>\n<ul>\n<li>컴퓨터에서 다룰 수 있는 데이터라면 무엇이든지 전송할수 있는 프로토콜이며, REST의 중요한 특징인 Uniform 인터페이스, 스테이트리스서버, 캐시 등을 구현하고 있는 web의 기반이 되는 프로토콜입니다.</li>\n</ul>\n<p>TCP/IP란?</p>\n<ul>\n<li>HTTP는 TCP/IP를 기반으로 하고있다.</li>\n<li>계층형 프로토콜</li>\n<li>네트워크 인터페이스 계층</li>\n<li>인터넷 계층</li>\n<li>트랜스포트 계층</li>\n<li>애플리케이션 계층</li>\n</ul>\n<h3>HTTP의 버전</h3>\n<ul>\n<li>HTTP-0.9 : 헤더가없고, 메서드는 GET뿐</li>\n<li>HTTP-1.0 : 헤더의 도입, GET이외의 메서드 추가 등 HTTP 1.1로 이어지는 기본적인 요소들이 도입</li>\n<li>HTTP-1.1 : 채널 전송, Accept 헤더에 의한 콘텐트 네고시에이션, 복잡한 캐시 컨트롤, 지속적 연결 등의 기능이 추가되었다.</li>\n</ul>\n<h3>클라이언트와 서버</h3>\n<ul>\n<li>웹은 아키텍처 스타일로 클라이언트/서버를 채용하고있다.</li>\n<li>클라이언트가 서버에 접속하여 요청을 보내면 응답을 받는 구조다.</li>\n</ul>\n<h3>요청과 응답</h3>\n<ul>\n<li>위와같은 프로콜을 가리켜 요청/응답형 프로토콜이라 한다.</li>\n<li>HTTP는 동기형 프로토콜이다.</li>\n<li>\n<p>클라이언트에서 일어나는 일들</p>\n<ol>\n<li>요청 메시지 구축</li>\n<li>요청 메시지 송신</li>\n<li>응답이 돌아올 때까지 대기</li>\n<li>응답 메시지 수신</li>\n<li>응답 메시지 해석</li>\n<li>클라이언트의 목적을 달성하기 위해 필요한 처리</li>\n</ol>\n</li>\n<li>\n<p>서버에서 일어나는 일들</p>\n<ol>\n<li>요청을 대기</li>\n<li>요청 메시지 수신</li>\n<li>요청 메시지 해석</li>\n<li>적절한 애플리케이션 프로그램으로 처리를 위임</li>\n<li>애플리케이션 프로그램으로부터 결과를 취득</li>\n<li>응답 메시지 구축</li>\n<li>응답 메시지 송신</li>\n</ol>\n</li>\n</ul>\n<h3>HTTP의 스테이트리스성</h3>\n<ul>\n<li>스테이트리스란 ‘서버가 클라이언트의 애플리케이션 상태를 보존하지 않는다’ 라는 제약이다.</li>\n<li>스테이트풀이란 서버가 클라이언트의 애플리케이션 상태를 기억하고 있는것</li>\n<li>애플리케이션 상태는 ‘세션상태’라고도 한다.</li>\n<li>스테이트풀의 결점은 클라이언트의 수가 증가함에 따라 서버가 클라이언트의 애플리케이션 상태를 기억하는 것이 어려워짐 ex) 오버헤드</li>\n<li>스테이트리스의 이점은 애플리케이션 상태를 기억할 필요가 없기 때문에 시스템이 단순해진다.</li>\n<li>\n<p>스테이트리스의 결점은</p>\n<ol>\n<li>송신한 데이터의 양이 많아진다.</li>\n<li>인증 등 서버에 부하가 걸리는 처리를 반복한다.</li>\n</ol>\n</li>\n</ul>\n<h4>결론</h4>\n<p>HTTP의 가장 큰 특징인 심플함은 강력한 무기이다. 심플하기 때문에 브라우저는 PC뿐만 아니라, 그 밖의 다양한 디바이스에서도 구현될 수 있게 되었고, 웹서비스와 웹 API가 같은 프로토콜로 실현될 수 있는 것이다.</p>\n<h2>Chapter08</h2>\n<h2>HTTP 메서드</h2>\n<ul>\n<li>GET : 리소스 취득</li>\n<li>POST : 서브 리소스의 작성, 리소스의 데이터의 추가, 그 밖의 처리</li>\n<li>PUT : 리소스의 갱신, 리소스의 작성</li>\n<li>DELETE : 리소스의 삭제</li>\n<li>HEAD : 리소스의 헤더(메타 데이터) 취득</li>\n<li>PATCH : 리소스의 수정, 일부를 교체</li>\n<li>OPTIONS : 리소스가 서포트하는 메서드의 취득</li>\n<li>TRACE : 자기 앞으로 요청 메시지를 반환(루프 백) 시험</li>\n<li>CONNECT : 프록시 동작의 터널 접속으로 변경</li>\n</ul>\n<h4>대표적인 메서드 GET POST PATCH DELETE</h4>\n<h3>조건부 요청</h3>\n<ul>\n<li>HTTP 메서드와 갱신일자 등으로 헤더를 구성하면 메서드의 실행 여부를 리소스의 갱신일자를 조건으로 서버가 선택할 수 있다. 이렇나 요청을 ‘조건부 요청’이라 한다</li>\n</ul>\n<h3>멱등성과 안정성</h3>\n<ul>\n<li>멱등성: 어떤 조작을 몇 번을 반복해도 결과가 동일한 것</li>\n<li>안정성: 조작대상의 리소스의 상태를 변화시키지 않는것</li>\n</ul>\n<h2>웹의 성공의 이유는 HTTP 메서드에 있다.</h2>\n<ul>\n<li>메서드를 한정하여 고정시켰기 때문에 결국 프로토콜이 심플하게 유지되었고 웹은 성공했다.</li>\n</ul>\n<h2>Chapter08</h2>\n<h2>스테이터스 코드</h2>\n<h3>스테이터스 코드의 중요성</h3>\n<ul>\n<li>스테이터스 라인 : 응답 메시지의 첫째 줄에 있는 프로토콜 버전, 스테이터스 코드, 텍스트 프레이즈로 이루어집니다. 이 중 가장 중요한 것이 바로 스테이터스 코드입니다.</li>\n</ul>\n<h3>스테이터스 코드의 분류와 의미</h3>\n<ul>\n<li>\n<p>1XX : 처리중</p>\n<ul>\n<li>처리가 계속되고있음을 나타냄</li>\n</ul>\n</li>\n<li>\n<p>2XX : 성공</p>\n<ul>\n<li>요청의 성공</li>\n</ul>\n</li>\n<li>\n<p>3XX : 리다이렉트</p>\n<ul>\n<li>다른 리소스로의 리다이렉트</li>\n</ul>\n</li>\n<li>\n<p>4XX : 클라이언트 에러</p>\n<ul>\n<li>클라이언트 에러를 나타냄. 원인은 클라이언트의 요청에 있다.</li>\n</ul>\n</li>\n<li>\n<p>5XX : 서버 에러</p>\n<ul>\n<li>서버 에러를 나타낸다.</li>\n</ul>\n</li>\n</ul>\n<h2>Chapter09</h2>\n<h2>HTTP 헤더</h2>\n<ul>\n<li>헤더는 메시지의 바디에 대한 부가적인 정보, 즉 메타 데이터를 표현합니다.</li>\n<li>클라이언트와 서버는 헤더를 보고 메시지에 대한 동작을 결정한다.</li>\n<li>리소스에 대한 접근권한을 설정하는 인증이나 클라이언트와 서버의 통신횟수와 양을 감소시키는 캐시 같은 HTTP의 기능을 헤더로 실현합니다.</li>\n</ul>\n<h3>날짜와 시간</h3>\n<p>날짜와 시간을 가지는 헤더</p>\n<p><code class=\"language-text\">Date: Tue, 06 Jul 2010 03:21:05 GMT</code></p>\n<h3>MIME 미디어 타입</h3>\n<ul>\n<li>메시지로 주고받는 리소스 표현의 종류를 지정하는 것이 MIME미디어 타입입니다.</li>\n<li>Content-Type 헤더는 그 메시지의 바디 내용이 어떠한 종류인가를 미디어 타입으로 나타낸다.</li>\n<li>미디어 타입은 charset 파라미터를 가질 수 있습니다.</li>\n<li>Content-Language 헤더는 리소스의 표현의 자연언어를 지정한다.</li>\n</ul>\n<h3>콘텐트 네고시에이션</h3>\n<ul>\n<li>미디어 타입과 문자 인코딩, 언어 태그는 서버가 일방적으로 결정하는 것뿐만 아니라, 클라이언트와 교섭해서 정할수있다. 이 방법을 콘텐트 네고시에이션 이라한다.</li>\n<li>Accept - 클라이언트가 처리할수 있는 미디어 타입을 전달한다.</li>\n<li>Accept-Charset - 처리할 수 있는 문자 인코딩을 전달한다.</li>\n</ul>\n<h3>인증</h3>\n<ul>\n<li>Basic 인증 - 유저 이름과 패스워드에 의한 인증방식, 유저 이름과 패스워드는 Authorization 헤더에 넣어 요청마다 전송합니다. Basic 인증을 사용할 때는 SSL,TLS,HTTPS 통신을하고 통신선로 상에서 암호화할 것인지 검토해야한다.</li>\n<li>Digest 인증 - Basic 인증보다 보안이 강화된 인증 방식이다. 메시지에 해시함수를 적용한 해시값을 말하며 요즘은 쓰지않는다.</li>\n</ul>\n<h3>개념탄탄</h3>\n<h3>OpenID와 OAuth</h3>\n<p>OpenID와 Oauth 모두 인증을 위한 오픈 스탠더드 프로토콜로, 이를 이용하면, Facebook과 같은 인터넷 서비스의 기능을 다른 어플리케이션 등에서도 사용할 수 있다.</p>\n<p>OAuth 사용 이전에도 다른 어플리케이션에 사용자의 아이디와 암호가 노출되지 않도록 하는 API 접근 위임이 가능한 여러 접근 방법이 있었지만 서로 통일되어있지 않았었고, 표준으로써 제정된 것이 OpenID와 Oauth 인증방식이다.</p>\n<p>OpenID와 Oauth 방식은 몇가지 공통점과 차이점을 갖고 있다. 일단 알아야 할 것은 두방식 모두 로그인과는 조금 다른 권한이라는 것을 의미하는 것이다.</p>\n<p>그 중에서도 OpenID의 주요 목적이 인증(Authentication)이라면 OAuth의 주요 목적은 허가(Authorization)이다.</p>\n<h4>OAuth의 인증과정</h4>\n<ol>\n<li>Request Token의 요청과 발급</li>\n<li>사용자 인증 페이지 호출</li>\n<li>사용자 로그인 완료</li>\n<li>사용자의 권한 요청 및 수락</li>\n<li>Access Token 발급</li>\n<li>Access Token을 이용해서 서비스 정보를 요청</li>\n</ol>\n<h3>캐시</h3>\n<ul>\n<li>캐시란, 서버로부터 가져온 리소스를 로컬 스토리지에 저장하여 재사용하는 방법이다.</li>\n<li>로컬 스토리지에 캐싱한 데이터 자체를 ‘캐시’라고 부른다.</li>\n<li>클라이언트가 저장한 캐시는 그 캐시의 유효기간 내에 다시 그 리소스에 접근하려고 했을 때 재사용된다.</li>\n<li>Pragma - 캐시를 억제한다.</li>\n<li>Expries - 캐시의 유효기한을 나타낸다.</li>\n<li>Cache-Control - 상세한 캐시 방법을 지정한다.</li>\n</ul>\n<h3>HTML이란 무엇인가.</h3>\n<ul>\n<li>Hypertext Markup Language의 줄임말이다.</li>\n<li>마크업 언어란 태그로 문서의 구조를 표현하는 컴퓨터 언어이다.</li>\n<li>\n<p>HTML의 미디어타입</p>\n<ul>\n<li>test/html</li>\n<li>SGML 베이스의 HTML</li>\n<li>application/xhtml+xml</li>\n<li>XML 베이스의 XHTML</li>\n</ul>\n</li>\n<li>.html 또는 .htm이라는 확장자를 사용한다.</li>\n</ul>","frontmatter":{"title":"웹을 지탱하는 기술 스터디 2회차","date":"December 29, 2019"},"id":"ed887e21-5c21-5ff3-a34f-e7c42e638cc2"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"Your Disqus-short-name here"}}}},"pageContext":{"slug":"/2019-12-29-study2/","previous":{"fields":{"slug":"/2019-12-22-study1_1/"},"frontmatter":{"title":"웹을 지탱하는 기술 스터디 1회차","tag":["Study"],"layout":null}},"next":{"fields":{"slug":"/2020-01-05-study3/"},"frontmatter":{"title":"웹을 지탱하는 기술 스터디 3회차","tag":["Study"],"layout":null}}}},"staticQueryHashes":["3668704128"]}