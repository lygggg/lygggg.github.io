{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-12-26-JS개념정리/","result":{"data":{"markdownRemark":{"html":"<h3>원시타입</h3>\n<p>있는 그대로 저장되는 데이터를 표현한다.</p>\n<ul>\n<li>true, false</li>\n<li>숫자</li>\n<li>문자열</li>\n<li>null</li>\n<li>undefined</li>\n</ul>\n<h3>특징</h3>\n<p>원시값을 변수에 할당하면 값이 복사되어 들어간다. 즉, 원시값이 할당된 변수들은 모두 자기 자신만의 고유한 값을 가지게된다.</p>\n<h3>typeof</h3>\n<p>원시값의 종류를 알 수 있게 해주는 메서드\n하지만 null을 출력할경우 object가 나오는데, 자바스크립트에서 object는 객체 참조타입을 의미하는데 이건 원시타입이 아니다. [자바스크립트 오류]</p>\n<h3>참조타입</h3>\n<p>자바스크립트 객체를 나타낸다.</p>\n<ul>\n<li>객체 {}</li>\n<li>배열 []</li>\n<li>함수 function</li>\n<li>Date</li>\n<li>정규표현식 RegExp</li>\n<li>원시타입 빼고 전부 참조타입</li>\n</ul>\n<h3>특징</h3>\n<p>참조 타입은 변수에 값을 직접 저장하지 않는다. 변수에 저장되는 것은 메모리 안에서 객체의 위치를 가리키는 “포인터” 이다. 즉 무엇이 저장되느냐, 이것이 원시 타입과 참조 타입의 가장 큰 차이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> objOne <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> one<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> objTwo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> two<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>\n\nobjTwo <span class=\"token operator\">=</span> objOne\n\nobjTwo<span class=\"token punctuation\">.</span>one <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>objOne<span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>objTwo<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결과를 출력해보면 둘다 값이 3인 것을 확인 할 수 있다.</p>\n<h3>원시 래퍼 타입</h3>\n<p>원시 타입을 객체처럼 편리하게 사용하도록 도와준다.</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n</ul>\n<h3>특징</h3>\n<p>원시 타입을 객체처럼 사용하는 순간, 자바스크립트 내부에서 사용하는 데이터의 인스턴스를 만들게됩니다. 이렇게 만들어진 객체는 코드를 실행후 바로 다음 줄에서 파괴됩니다. 이러한 과정을 오토박싱이라고 한다.</p>\n<h3>this</h3>\n<p>this를 이용하면 함수를 다른 객체에서 사용 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">menuGlobal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'오늘 저녁은'</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> myDiner <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'김치찌개'</span><span class=\"token punctuation\">,</span>\n  menu<span class=\"token operator\">:</span> menuGlobal<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> yourDiner <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'된장찌개'</span><span class=\"token punctuation\">,</span>\n  menu<span class=\"token operator\">:</span> menuGlobal<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\nmyDiner<span class=\"token punctuation\">.</span><span class=\"token function\">menu</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nyourDiner<span class=\"token punctuation\">.</span><span class=\"token function\">menu</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>this제어</h3>\n<ul>\n<li>\n<p>call()</p>\n<ul>\n<li>call 메서드는 this의 값을 바꿀 수 있고, 함수를 실행할 때 사용할 인수도 전달할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">menuGlobal</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"오늘 저녁은\"</span> <span class=\"token operator\">+</span> item <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> myDiner <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token operator\">:</span> <span class=\"token string\">\"김치찌개\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> yourDiner <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"된장찌개\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">menuGlobal</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>myDiner<span class=\"token punctuation\">,</span> <span class=\"token string\">\"묵은지\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">menuGlobal</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>yourDiner<span class=\"token punctuation\">,</span> <span class=\"token string\">\"삼겹살\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span>`tsx\n\n<span class=\"token operator\">-</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token operator\">-</span> apply 메서드는 함수를 실행할 때 인수를 배열로 묶어 한번에 전달한다<span class=\"token punctuation\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>function menuGlobal(item1, item2) {\n[item1, item2].forEach(function(el){</p>\n<p>console.log(“오늘 저녁은 ” + el + this.name)\n},this)\n}</p>\n<p>var myDiner = {\nname : “김치찌개”\n}</p>\n<p>var yourDiner = {\nname: “된장찌개”\n}</p>\n<p>menuGlobal.apply(myDiner, [“묵은지”, “삼겹살”])</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">### bind()\n\nbind 메서드는 es5에서 추가되었다. this값을 어디서 사용하든 호출 객체가 바뀌지 않게 고정시켜버린다.\n\n### 화살표 함수와 this\n\n화살표 함수의 this는 일반적인 this처럼 함수를 호출한 객체를 할당하지 않고, 바로 상위 스코프의 this를 할당한다.\n\n### 스코프\n\n스코프는 이름이 출동하는 문제를 덜어주고, 자동으로 메모리를 관리한다.\n\n### 전역 스코프\n\n스크립트의 어디서든 접근이 가능하기 때문에 사용이 쉽다. 타인과의 협업, 라이브러리 사용시 충돌의 가능성이 있다.\n\n### 함수 스코프\n\n함수 내부에서 정의된 변수와 매개변수는 함수외부에서 접근할 수 없다. 함수 내부에서 정의된 변수라면 함수의 어느 부분에서도 접근 할 수 있다.\n\n### 블록 스코프\n\n중괄호 안에서만 접근이 가능하다. 블록 내부에 정의된 변수는 블록의 실행이 끝나면 해제된다.\n\n### 스코프 정리\n\n- 스코프는 변수의 접근성과 생존기간을 제어한다.\n- 스코프는 이름이 충돌하는 문제를 덜어주고, 자동으로 메모리를 관리한다.\n- 자바스크립트에는 전역 스코프, 함수 스코프, 블록스코프가 존재한다.\n\n### 클로저\n\n말로 표현하면 폐쇄된 공간에 대한 접근 권한을 가진함수를 말한다.\n\n만약 내부 함수가 외부 함수보다 오래 살아있는 경우에, 외부함수에 있던 변수들은 어떻게 될까?</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>var outer = function() { // 외부함수\nvar a = 1; // outer함수가 반환된 후에도 inner함수는 outer 함수 안에 있는 a에 대한 접근 권한을 가진다. 그래서 변수 a는 메모리에서 해제되지 않은 상태이다.</p>\n<p>var inner = function() { // 내부함수\nvar b = 5;\nvar c = 6;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a = a + b + c;\nconsole.log(a);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>};\nreturn inner;\n};</p>\n<p>var newInner = outer();</p>\n<p>newInner();</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">이러한 특징을 이용하면 비공개 데이터를 가진 객체를 만들어 볼 수 있지 않을까?</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>var person = (function() {\nvar age = 15;</p>\n<p>return {\nname : “Wade”,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">getAge : function() {\n  console.log(age);\n  return age;\n},\n\nsetAge : function(val) {\n  age = val;\n  console.log(age);\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>};\n})();\nperson.setAge(20); // person //이런 방식으로 외부함수에 있는 데이터를 변경할 수 있다.\nperson.getAge();</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">### 프로토타입</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>function Food(name) {\nthis.name = name;\nthis.smell = function() {\nconsole.log(this.name + “냄새가 난다”);\n}\n}</p>\n<p>var myFood = new Food(“로제 파스타”);\nvar myFood2 = new Food(“창란젓”);</p>\n<p>console.log(myFood.smell === myFood2.smell); // false</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myFood.smell 메소드와 myFood2.smell 메소드는 서로 다른 참조를 하고 있었다.\n\n즉 객체를 생성 할때마다 별개의 함수가 계속 만들어 진것. 앞서 this에서 배운 내용을 바탕으로 좀 더 효율적인 공정으로 바꿔보자</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>function smell() {\nconsole.log(this.name + “냄새가 난다”);\n}</p>\n<p>function Food(name) {\nthis.name = name;\nthis.smell = smell;</p>\n<p>}</p>\n<p>var myFood = new Food(“로제 파스타”);\nvar myFood2 = new Food(“창란젓”);</p>\n<p>myFood.smell();\nmyFood2.smell();\nconsole.log(myFood.smell === myFood2.smell); // true</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">smell 함수를 밖으로 빼 문제를 해결했다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>myFood.constructor === Food // true // constructor는 어디서 온걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">자바스크립트에서는 생성자의 prototype 프로퍼티를 통해 타입의 특징을 정의한다.\n\n모든 인스턴스는 내부에 [[Prototype]] 프로퍼티를 가지며, 이를 통해 생성자의 prototype 프로퍼티를 추적한다.\n\n&lt;img src=&quot;../assets/images/prototype.png&quot; width=&quot;300px&quot; height=&quot;300px&quot;/&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Food.prototype.smell = function() {\nconsole.log(this.name + “냄새가 난다”);\n}</p>\n<p>function Food(name) {\nthis.name = name;</p>\n<p>}</p>\n<p>var myFood = new Food(“로제 파스타”);\nvar myFood2 = new Food(“창란젓”);</p>\n<p>myFood.smell();\nmyFood2.smell();\nconsole.log(myFood.smell === myFood2.smell);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">이렇게 했더니 결과값이 같다.\n\nmyFood [[prototype]] -&gt; Food [[Prototype]] -&gt; Object [[Prototype]] -&gt; null\n\n이런식으로 인스턴스에서 생성자의 [[Prototype]]을 타고 올라가며 프로퍼티를 탐색하는 현상을 프로토타입 체인이라고 한다.\n\n### 정리\n\n- 자바스크립트는 생성자의 prototype 프로퍼티를 통해 타입의 특징을 정의한다.\n- 모든 인스턴스는 내부에 [[Prototype]]프로퍼티를 가지며 이를 통해 생성자의 prototype 프로퍼티를 추적한다.\n- 인스턴스에서 생성자의 [[Prototype]]을 타고 올라가며 프로퍼티를 탐색하는 현상을 프로토타입 체인이라고 한다.\n\n브라우저 콘솔에 직접 쳐보면\n&lt;img src=&quot;../assets/images/prototypes.png&quot; width=&quot;300px&quot; height=&quot;300px&quot;/&gt;&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 확인이 가능g하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">### 클래스\n\n클래스는 정확히 생성자를 이용한 타입 생성과 그 결과가 일치한다.\n\n자바스크립트만의 사용자 정의타입 생성 방법을 다른 언어의 클래스 문법처럼 바꿔준것이 바로 자바스크립트 클래스다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>class User {\nconstructor(name) {\nthis.name = name;\n}\nsayName() {\nconsole.log(this.name);\n}\n}</p>\n<p>var me = new User(“Wade”);\nme.sayName(); // wade</p>\n<p>function UserOld(name) {\nthis.name = name;\n}</p>\n<p>UserOld.prototype.sayName = function() {\nconsole.log(this.name)\n}</p>\n<p>var user = new UserOld(“Wade”);\nuser.sayName(); //wade</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">위 아래 코드처럼 내부동작은 동일하지만, 더 보기 좋고 편리하게 개선된 문법을 슈가 신텍스라고 부른다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>class Sausage {\nconstructor(el1, el2) {\nthis.inside1 = el1;\nthis.inside2 = el2;\n}</p>\n<p>taste() {\nreturn this.inside1+ “와” + this.inside2 + “맛이 난다!”;\n}\n}</p>\n<p>var classicSausage = new Sausage(“닭고기”, “양파”);\n// console.log(classicSausage.taste());</p>\n<p>class FireSausage extends Sausage{\nconstructor(el1, el2, el3) {\nsuper(el1, el2);\nthis.inside3 = el3;\n}\nflavor(){\nreturn this.inside3 + “의 풍미도 있다!”;\n}\n}</p>\n<p>var classicFireSausage = new FireSausage(“소고기”, “파”,“불맛”);\nconsole.log(classicFireSausage.flavor());</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">이런식으로도 자바랑 비슷하게 사용할수 있다.\n\n### 정리\n\n- 자바스크립트의 타입 생성 방법을 다른 언어와 비슷하도록 보기 쉽게 개선한 것이 바로 자바스크립트 클래스다.\n- extends 연산자를 통해 상위 타입의 프로퍼티를 상속받습니다.\n- super 메소드를 통해 자식 클래스의 생성자 함수가 부모 클래스의 생성자 함수를 덮어 씌우는 것을 방지 할 수 있다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","frontmatter":{"title":"JS개념정리","date":"December 26, 2021"},"id":"67fbae34-8865-5a26-8088-ed51a19f33ab"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"lyg"}}}},"pageContext":{"slug":"/2021-12-26-JS개념정리/","previous":{"fields":{"slug":"/2021-12-26-JS개념정리/"},"frontmatter":{"title":"JS개념정리","tag":["JS"],"layout":null}},"next":{"fields":{"slug":"/2021-12-26-JS개념정리/"},"frontmatter":{"title":"JS개념정리","tag":["JS"],"layout":null}}}},"staticQueryHashes":["3668704128"]}