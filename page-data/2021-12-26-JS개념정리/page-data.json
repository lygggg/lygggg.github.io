{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-12-26-JS개념정리/","result":{"data":{"markdownRemark":{"html":"<h3>원시타입</h3>\n<p>있는 그대로 저장되는 데이터를 표현한다.</p>\n<ul>\n<li>true, false</li>\n<li>숫자</li>\n<li>문자열</li>\n<li>null</li>\n<li>undefined</li>\n</ul>\n<h3>특징</h3>\n<p>원시값을 변수에 할당하면 값이 복사되어 들어간다. 즉, 원시값이 할당된 변수들은 모두 자기 자신만의 고유한 값을 가지게된다.</p>\n<h3>typeof</h3>\n<p>원시값의 종류를 알 수 있게 해주는 메서드\n하지만 null을 출력할경우 object가 나오는데, 자바스크립트에서 object는 객체 참조타입을 의미하는데 이건 원시타입이 아니다. [자바스크립트 오류]</p>\n<h3>참조타입</h3>\n<p>자바스크립트 객체를 나타낸다.</p>\n<ul>\n<li>객체 {}</li>\n<li>배열 []</li>\n<li>함수 function</li>\n<li>Date</li>\n<li>정규표현식 RegExp</li>\n<li>원시타입 빼고 전부 참조타입</li>\n</ul>\n<h3>특징</h3>\n<p>참조 타입은 변수에 값을 직접 저장하지 않는다. 변수에 저장되는 것은 메모리 안에서 객체의 위치를 가리키는 “포인터” 이다. 즉 무엇이 저장되느냐, 이것이 원시 타입과 참조 타입의 가장 큰 차이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const objOne = {one : 1};\n\nconst objTwo = {two : 2};\n\nobjTwo = objOne;\n\nobjTwo.one = 3;\n\nconsole.log(objOne);\nconsole.log(objTwo);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결과를 출력해보면 둘다 값이 3인 것을 확인 할 수 있다.</p>\n<h3>원시 래퍼 타입</h3>\n<p>원시 타입을 객체처럼 편리하게 사용하도록 도와준다.</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n</ul>\n<h3>특징</h3>\n<p>원시 타입을 객체처럼 사용하는 순간, 자바스크립트 내부에서 사용하는 데이터의 인스턴스를 만들게됩니다. 이렇게 만들어진 객체는 코드를 실행후 바로 다음 줄에서 파괴됩니다. 이러한 과정을 오토박싱이라고 한다.</p>\n<h3>this</h3>\n<p>this를 이용하면 함수를 다른 객체에서 사용 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function menuGlobal() {\n  console.log(&quot;오늘 저녁은&quot; + this.name);\n}\n\nvar myDiner = {\n  name: &quot;김치찌개&quot;,\n  menu: menuGlobal\n}\n\nvar yourDiner = {\n  name: &quot;된장찌개&quot;,\n  menu: menuGlobal\n}\nmyDiner.menu()\nyourDiner.menu()</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>this제어</h3>\n<ul>\n<li>\n<p>call()</p>\n<ul>\n<li>call 메서드는 this의 값을 바꿀 수 있고, 함수를 실행할 때 사용할 인수도 전달할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function menuGlobal(item) {\n  console.log(&quot;오늘 저녁은&quot; + item + this.name)\n}\n\nvar myDiner = {\n  name : &quot;김치찌개&quot;\n}\n\nvar yourDiner = {\n  name: &quot;된장찌개&quot;\n}\n\nmenuGlobal.call(myDiner, &quot;묵은지&quot;);\nmenuGlobal.call(yourDiner, &quot;삼겹살&quot;);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p>apply()</p>\n<ul>\n<li>apply 메서드는 함수를 실행할 때 인수를 배열로 묶어 한번에 전달한다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function menuGlobal(item1, item2) {\n  [item1, item2].forEach(function(el){\n\n  console.log(&quot;오늘 저녁은 &quot; + el + this.name)\n  },this)\n}\n\nvar myDiner = {\n  name : &quot;김치찌개&quot;\n}\n\nvar yourDiner = {\n  name: &quot;된장찌개&quot;\n}\n\nmenuGlobal.apply(myDiner, [&quot;묵은지&quot;, &quot;삼겹살&quot;])</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>bind()</h3>\n<p>bind 메서드는 es5에서 추가되었다. this값을 어디서 사용하든 호출 객체가 바뀌지 않게 고정시켜버린다.</p>\n<h3>화살표 함수와 this</h3>\n<p>화살표 함수의 this는 일반적인 this처럼 함수를 호출한 객체를 할당하지 않고, 바로 상위 스코프의 this를 할당한다.</p>\n<h3>스코프</h3>\n<p>스코프는 이름이 출동하는 문제를 덜어주고, 자동으로 메모리를 관리한다.</p>\n<h3>전역 스코프</h3>\n<p>스크립트의 어디서든 접근이 가능하기 때문에 사용이 쉽다. 타인과의 협업, 라이브러리 사용시 충돌의 가능성이 있다.</p>\n<h3>함수 스코프</h3>\n<p>함수 내부에서 정의된 변수와 매개변수는 함수외부에서 접근할 수 없다. 함수 내부에서 정의된 변수라면 함수의 어느 부분에서도 접근 할 수 있다.</p>\n<h3>블록 스코프</h3>\n<p>중괄호 안에서만 접근이 가능하다. 블록 내부에 정의된 변수는 블록의 실행이 끝나면 해제된다.</p>\n<h3>스코프 정리</h3>\n<ul>\n<li>스코프는 변수의 접근성과 생존기간을 제어한다.</li>\n<li>스코프는 이름이 충돌하는 문제를 덜어주고, 자동으로 메모리를 관리한다.</li>\n<li>자바스크립트에는 전역 스코프, 함수 스코프, 블록스코프가 존재한다.</li>\n</ul>\n<h3>클로저</h3>\n<p>말로 표현하면 폐쇄된 공간에 대한 접근 권한을 가진함수를 말한다.</p>\n<p>만약 내부 함수가 외부 함수보다 오래 살아있는 경우에, 외부함수에 있던 변수들은 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var outer = function() { // 외부함수\n  var a = 1; // outer함수가 반환된 후에도 inner함수는 outer 함수 안에 있는 a에 대한 접근 권한을 가진다. 그래서 변수 a는 메모리에서 해제되지 않은 상태이다.\n\n  var inner = function() { // 내부함수\n    var b = 5;\n    var c = 6;\n\n    a = a + b + c;\n    console.log(a);\n  };\n  return inner;\n};\n\nvar newInner = outer();\n\nnewInner();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 특징을 이용하면 비공개 데이터를 가진 객체를 만들어 볼 수 있지 않을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var person = (function() {\n  var age = 15;\n\n  return {\n    name : &quot;Wade&quot;,\n\n    getAge : function() {\n      console.log(age);\n      return age;\n    },\n\n    setAge : function(val) {\n      age = val;\n      console.log(age);\n    }\n  };\n})();\nperson.setAge(20); // person //이런 방식으로 외부함수에 있는 데이터를 변경할 수 있다.\nperson.getAge();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>프로토타입</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function Food(name) {\n  this.name = name;\n  this.smell = function() {\n    console.log(this.name + &quot;냄새가 난다&quot;);\n  }\n}\n\nvar myFood = new Food(&quot;로제 파스타&quot;);\nvar myFood2 = new Food(&quot;창란젓&quot;);\n\nconsole.log(myFood.smell === myFood2.smell); // false</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>myFood.smell 메소드와 myFood2.smell 메소드는 서로 다른 참조를 하고 있었다.</p>\n<p>즉 객체를 생성 할때마다 별개의 함수가 계속 만들어 진것. 앞서 this에서 배운 내용을 바탕으로 좀 더 효율적인 공정으로 바꿔보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function smell() {\n    console.log(this.name + &quot;냄새가 난다&quot;);\n  }\n\nfunction Food(name) {\n  this.name = name;\n  this.smell = smell;\n\n}\n\nvar myFood = new Food(&quot;로제 파스타&quot;);\nvar myFood2 = new Food(&quot;창란젓&quot;);\n\nmyFood.smell();\nmyFood2.smell();\nconsole.log(myFood.smell === myFood2.smell); // true</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>smell 함수를 밖으로 빼 문제를 해결했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myFood.constructor === Food // true // constructor는 어디서 온걸까?</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자바스크립트에서는 생성자의 prototype 프로퍼티를 통해 타입의 특징을 정의한다.</p>\n<p>모든 인스턴스는 내부에 [[Prototype]] 프로퍼티를 가지며, 이를 통해 생성자의 prototype 프로퍼티를 추적한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 301px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.3953488372093%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsSAAALEgHS3X78AAACNUlEQVQ4y5WUi27aQBRE+f+fa9REBQw0YPyGfdrrF4bp7Dak0JBUtXRlZHvPzsy9y+xyuaDveqRZhiTNMI4n/Ovyaz67Zv5l13WI4z222y2EEMjzHG3bouW9yVhpClOWqMyI6Xz5EhqAvk7TCekyRRJlOMYx1GoNs4qgee9tjaHt0A4Tzpc/wEfQ2fXhOI5w2sEWNdyxRle78IxL/8v27HYneZDIFzlEJqBkA3lUhE6MpA8R+GiGYXj//n3tDXt2u5sxBvXBwlYG9mDgjENT96iqA5IkYc5xyPcKuhVz/X2n0DkHcySsZB0tWuswseuuHSCFJLx5i+Fz+3cK/ceqkjC5hkpZmYYuNaPQ2Gx2WC6WWEUrFEWBqqyovAqu7hR6/1fgQKAWHqQIMtAemHADYSFlTVhE6CKAn749Yfu6Reva+6Z8UHjUMAWLQJlJKA8sDATvsmQpi2i5wvzHPAD97K45Wj5fv/4D0AgTgLa00AQZNknlMiiMd3us1xva/4nddhfsZzxh5/MZp9PpzfJfQO0Vsss+R1FpHLhBRJsR7S7mcwz98OWxvAMO4wBLS96iTGlXNKhygZhqXmlPSY2+70MjrOV4GRvm08/mNE0PgHzR2Ib5ebtUGP/OrzMdXNMR0mFDy74pz9+fQ47xLg5dvyp/CKx59FSuqFLxKHLAVUM13Mi2yPhH4YHz+SJkmCZpGCG/9iHQ8QzXoobcy6DQN6ZVHPg3YMGT8vL8EhRGywj7/f4O+Au21s8tDJSnvAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype\" title=\"prototype\" src=\"/static/b834fdc4a26e94369983d91d6c95e1ac/fb933/prototype.png\" srcset=\"/static/b834fdc4a26e94369983d91d6c95e1ac/158c9/prototype.png 155w,\n/static/b834fdc4a26e94369983d91d6c95e1ac/fb933/prototype.png 301w\" sizes=\"(max-width: 301px) 100vw, 301px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Food.prototype.smell = function() {\n    console.log(this.name + &quot;냄새가 난다&quot;);\n  }\n\nfunction Food(name) {\n  this.name = name;\n\n}\n\nvar myFood = new Food(&quot;로제 파스타&quot;);\nvar myFood2 = new Food(&quot;창란젓&quot;);\n\nmyFood.smell();\nmyFood2.smell();\nconsole.log(myFood.smell === myFood2.smell);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 했더니 결과값이 같다.</p>\n<p>myFood [[prototype]] -> Food [[Prototype]] -> Object [[Prototype]] -> null</p>\n<p>이런식으로 인스턴스에서 생성자의 [[Prototype]]을 타고 올라가며 프로퍼티를 탐색하는 현상을 프로토타입 체인이라고 한다.</p>\n<h3>정리</h3>\n<ul>\n<li>자바스크립트는 생성자의 prototype 프로퍼티를 통해 타입의 특징을 정의한다.</li>\n<li>모든 인스턴스는 내부에 [[Prototype]]프로퍼티를 가지며 이를 통해 생성자의 prototype 프로퍼티를 추적한다.</li>\n<li>인스턴스에서 생성자의 [[Prototype]]을 타고 올라가며 프로퍼티를 탐색하는 현상을 프로토타입 체인이라고 한다.</li>\n</ul>\n<p>브라우저 콘솔에 직접 쳐보면\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 380px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 127.63157894736842%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsSAAALEgHS3X78AAADhklEQVRIx51V65aiOBjs93+/2dnT2qIgyP2SkATCpbYSWsf2Mj+WcyIaSVHfV5XKxziM0IlEH7YQ5xZx3CHi/XPfICsk7GJxvdZ1fRrX+ev14T7G1kB9tUjjC35/7jDqHtFnhTLqMNUGRhkM4x/g++se7AYIznV1i/M5RpoXKOsazaXEEAmU5xzhOcGgFcYkgeEztiigyhLTPD8zdD+U1v7PaZowz4u/W2ux8vu8bPNYFyycW/h95bMLx8uSl2WBdQv+5/VU8jqvsJVGWWicQomqVrBtD5VKXPIMZVlhOAbQ4RlDGMK0HQnMb0X6WFjWmPfIU4XjSSBOelilYKh8VVSILyl0msLs9lBNs4E9sPrBcBxHtG2Lxo8Oo7VepR9v3nTbhgN7wezG0BhDVhckZDIQHA+LV/Z4XX4uWpZtvAR0apa0QErQummR0xqDEBgOAczh6Ps29T0E59z/o1HYxRL/pot/+fJQ/ce3Vsh+JUj/SWE7Abk/wLJvU5rdHnQ2cY7YxvrdxhcM3bSUEtkhRfp1geg1CvZSDQMMW9CR2dbXJ8O81MYDurLbrkObUZhLjTou0RUdmkbgwNJdf4s892U/2uX2+36nuEuw1Cqt0JQELRr6suIOMgjDiCNk/xoMZP1o5mdjf0+MdkSd1+jSDh2Z1nENIzUyzjmWTji3RW+s3ql8fWDinq1ZbhdwhA1EtMWZFgMqlr7f73EIAsZbzHg7I81yGDM89/AGOE8eUJw7iIT9PDFxggqyUmjIOGHiZFmBY3DEbv+FvCjR007bUP4+MuLuAGc0aQNJMHlh2VHjmfbc0y3nRMUeVy0CAoZRhCg6+/7mjLKCI6donZAvAJnYrlSZSSotafQcJQ19PJ22RXSDs1nFzLR2+nvJTbYBtmGNvjOoWsEEOnlRcgbvu/h6KYqdLGQnWbLw5QoCN2eW3JBp5/pD0eoKCbdmzHGhN3syVUr73XMF/8OQIduL3vdMxK0XxfXTUmWteJBpS5DE9y84Hsk85Iu2lHIp/wToGAraQxc9mmOF+qv0TA0DVwqDnqA5A3fHXNzRQkFw8ozfAs4UZaCvVC69XXreZSkxSp56ZoRbo2iNjP5z4rgkVwxirbUPiyfAhYeQapnU9N3AY9W0mlE10F+aas5c3PugmKb51rNXZ8tdyU7lGpPmiWcsFEuf2TfZD75/cRL7/rkSnYnfhcR/PFTfDdBAbtoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototypes\" title=\"prototypes\" src=\"/static/e9a6b912bf0e13308d2e1e4d3a826392/3f520/prototypes.png\" srcset=\"/static/e9a6b912bf0e13308d2e1e4d3a826392/158c9/prototypes.png 155w,\n/static/e9a6b912bf0e13308d2e1e4d3a826392/5fad2/prototypes.png 310w,\n/static/e9a6b912bf0e13308d2e1e4d3a826392/3f520/prototypes.png 380w\" sizes=\"(max-width: 380px) 100vw, 380px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">이렇게 확인이 가능g하다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3>클래스</h3>\n<p>클래스는 정확히 생성자를 이용한 타입 생성과 그 결과가 일치한다.</p>\n<p>자바스크립트만의 사용자 정의타입 생성 방법을 다른 언어의 클래스 문법처럼 바꿔준것이 바로 자바스크립트 클래스다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class User {\n  constructor(name) {\n    this.name = name;\n  }\n  sayName() {\n    console.log(this.name);\n  }\n}\n\nvar me = new User(&quot;Wade&quot;);\nme.sayName(); // wade\n\nfunction UserOld(name) {\n  this.name = name;\n}\n\nUserOld.prototype.sayName = function() {\n  console.log(this.name)\n}\n\nvar user = new UserOld(&quot;Wade&quot;);\nuser.sayName(); //wade</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 아래 코드처럼 내부동작은 동일하지만, 더 보기 좋고 편리하게 개선된 문법을 슈가 신텍스라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Sausage {\n  constructor(el1, el2) {\n    this.inside1 = el1;\n    this.inside2 = el2;\n  }\n\n  taste() {\n    return this.inside1+ &quot;와&quot; + this.inside2 + &quot;맛이 난다!&quot;;\n  }\n}\n\nvar classicSausage = new Sausage(&quot;닭고기&quot;, &quot;양파&quot;);\n// console.log(classicSausage.taste());\n\nclass FireSausage extends Sausage{\n  constructor(el1, el2, el3) {\n    super(el1, el2);\n    this.inside3 = el3;\n  }\n  flavor(){\n    return this.inside3 + &quot;의 풍미도 있다!&quot;;\n  }\n}\n\nvar classicFireSausage = new FireSausage(&quot;소고기&quot;, &quot;파&quot;,&quot;불맛&quot;);\nconsole.log(classicFireSausage.flavor());</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런식으로도 자바랑 비슷하게 사용할수 있다.</p>\n<h3>정리</h3>\n<ul>\n<li>자바스크립트의 타입 생성 방법을 다른 언어와 비슷하도록 보기 쉽게 개선한 것이 바로 자바스크립트 클래스다.</li>\n<li>extends 연산자를 통해 상위 타입의 프로퍼티를 상속받습니다.</li>\n<li>super 메소드를 통해 자식 클래스의 생성자 함수가 부모 클래스의 생성자 함수를 덮어 씌우는 것을 방지 할 수 있다.</li>\n</ul>\n<h2>호이스팅</h2>","frontmatter":{"title":"JS개념정리","date":"December 26, 2021"},"id":"67fbae34-8865-5a26-8088-ed51a19f33ab"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"lyg"}}}},"pageContext":{"slug":"/2021-12-26-JS개념정리/","previous":{"fields":{"slug":"/2021-12-26-JS개념정리/"},"frontmatter":{"title":"JS개념정리","tag":["JS"],"layout":null}},"next":{"fields":{"slug":"/2021-12-26-JS개념정리/"},"frontmatter":{"title":"JS개념정리","tag":["JS"],"layout":null}}}},"staticQueryHashes":["3668704128"]}