{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-01-12-class/","result":{"data":{"markdownRemark":{"html":"<h2>목적</h2>\n<p>자바스크립트는 프로토타입 기반 객체지향 언어다. 프로토타입 기반 프로그래밍은 클래스가 필요 없는 객체지향 프로그래밍 스타일로 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화 등의 개념을 구현할 수 있다. 하지만 ES6부터는 클래스 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순 명료한 새로운 문법을 제시하고 있다. 우리는 자바스크립트 문법에서 사용하는 Class에 대해서 공부할 것이다.</p>\n<h2>클래스 정의</h2>\n<p>클래스는 다음과 같이 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 클래스 선언문\nclass Person {\n// constructor(생성자)\n    constructor(name) {\n        this._name = name;\n    }\n\n    sayHi() {\n        console.log(`Hi ${this._name}`);\n    }\n}\n\n// 인스턴스 생성\nconst me = new Person(&#39;Lee&#39;);\nme.sayHi(); //Hi Lee\n\nconsole.log(me instanceof Person) // true</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>클래스는 클래스 선언문 이전에 참조할 수 없다. 하지만 호이스팅이 발생하지 않는 것은 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const Foo = &#39;&#39;;\n\n{\n  // 호이스팅이 발생하지 않는다면 &#39;&#39;가 출력되어야 한다.\n  console.log(Foo);\n  // ReferenceError: Cannot access &#39;Foo&#39; before initialization\n  class Foo {}\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>표현식으로도 클래스를 정의할 수 있다. 함수와 마찬가지로 클래스는 이름을 가질 수도 갖지 않을 수도 있다. 함수와 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 클래스명 MyClass는 함수 표현식과 동일하게 클래스 몸체 내부에서만 유효한 식별자이다.\nconst Foo = class MyClass {};\n\nconst foo = new Foo();\nconsole.log(foo);  // MyClass {}\n\nnew MyClass(); // ReferenceError: MyClass is not defined</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>인스턴스 생성</h2>\n<p>생성자 함수와 같이 new 연산자와 함께 클래스 이름을 호출하면 클래스의 인스턴스가 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo {}\n\nconst foo = new Foo();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>new와 함께 호출한 Foo는 클래스가 아니라 constructor(생성자)이다.\n생성자는 new 연산자 없이 호출할 수 없다.</p>\n<h2>constructor</h2>\n<p>constructor는 인스턴스를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">클래스 필드란?\n\n자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Person {\n    // constructor(생성자). 이름을 바꿀 수 없다.\n    constructor(name) {\n        // _name의 클래스 필드이다.\n        this._name = name;\n    }\n}\n\n// 인스턴스 생성\nconst me = new Person(&#39;Lee&#39;);\nconsole.log(me);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>constructor는 클래스 내에 한 개만 존재할 수 있다. 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 constructor이다. constructor의 파라미터에 전달한 값은 클래스 필드에 할당한다. constructor는 생략할 수 있으나 위와 동일하게 동작한다. 즉 빈 객체를 생성하는데 따로 프로퍼티를 동적으로 추가해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo { }\n\nconst foo = new Foo();\nconsole.log(foo); // Foo {}\n\n// 프로퍼티 동적 할당 및 초기화\nfoo.num = 1;\nconsole.log(foo); // Foo&amp;nbsp;{ num: 1 }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>constructor는 인스턴스 생성과 동시에 클래스 필드의 생성과 초기화를 실행한다. 따라서 클래스 필드를 초기화하기 위해선 constructor를 생략하면 안 된다.</p>\n<h2>클래스 필드</h2>\n<ul>\n<li>클래스 몸체에서는 메소드만 선언 가능하다.</li>\n<li>클래스 필드의 선언과 초기화는 반드시 constructor 내부에서 실시한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo {\n  constructor(name = &#39;&#39;) {\n    this.name = name; // 클래스 필드의 선언과 초기화\n  }\n}\nconst foo = new Foo(&#39;Lee&#39;);\nconsole.log(foo); // Foo { name: &#39;Lee&#39; }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>constructor 내부에서 선언한 클래스 필드는 클래스가 생성할 인스턴스를 가리키는 this에 바인딩하고, 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 예를 들어 public이다.</p>\n<h2>getter, setter</h2>\n<h3>getter</h3>\n<ul>\n<li>getter는 클래스 필드에 접근할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용한다.</li>\n<li>메소드 이름 앞에 get 키워드를 사용해 정의한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo {\n  constructor(arr = []) {\n    this._arr = arr;\n  }\n\n  // getter: get 키워드 뒤에 오는 메소드 이름 firstElem은 클래스 필드 이름처럼 사용된다.\n  get firstElem() {\n    // getter는 반드시 무언가를 반환해야 한다.\n    return this._arr.length ? this._arr[0] : null;\n  }\n}\n\nconst foo = new Foo([1, 2]);\n// 필드 firstElem에 접근하면 getter가 호출된다.\nconsole.log(foo.firstElem); // 1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>setter</h3>\n<ul>\n<li>setter는 클래스 필드에 값을 할당할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용한다.</li>\n<li>메도스 이름 앞에 set 키워드를 사용해 정의한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo {\n  constructor(arr = []) {\n    this._arr = arr;\n  }\n\n  // getter: get 키워드 뒤에 오는 메소드 이름 firstElem은 클래스 필드 이름처럼 사용된다.\n  get firstElem() {\n    // getter는 반드시 무언가를 반환하여야 한다.\n    return this._arr.length ? this._arr[0] : null;\n  }\n\n  // setter: set 키워드 뒤에 오는 메소드 이름 firstElem은 클래스 필드 이름처럼 사용된다.\n  set firstElem(elem) {\n    // ...this._arr은 this._arr를 개별 요소로 분리한다\n    this._arr = [elem, ...this._arr];\n  }\n}\n\nconst foo = new Foo([1, 2]);\n\n// 클래스 필드 lastElem에 값을 할당하면 setter가 호출된다.\nfoo.firstElem = 100;\n\nconsole.log(foo.firstElem); // 100</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>getter와 setter는 접근자 프로퍼티(accessor property)이다.</p>\n<h2>정적 메소드</h2>\n<ul>\n<li>클래스의 정적 메소드를 정의할 때 static 키워드를 사용한다.</li>\n<li>정적 메소드는 클래스 인스턴스가 아닌 클래스 이름으로 호출한다. 따라서 클래스의 인스턴스를 생성하지 않아도 호출할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">class Foo {\n  constructor(prop) {\n    this.prop = prop;\n  }\n\n  static staticMethod() {\n    /*\n    정적 메소드는 this를 사용할 수 없다.\n    정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다.\n    */\n    return &#39;staticMethod&#39;;\n  }\n\n  prototypeMethod() {\n    return this.prop;\n  }\n}\n\n// 정적 메소드는 클래스 이름으로 호출한다.\nconsole.log(Foo.staticMethod());\n\nconst foo = new Foo(123);\n// 정적 메소드는 인스턴스로 호출할 수 없다.\nconsole.log(foo.staticMethod()); // Uncaught TypeError: foo.staticMethod is not a function</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var Foo = (function () {\n  // 생성자 함수\n  function Foo(prop) {\n    this.prop = prop;\n  }\n\n  Foo.staticMethod = function () {\n    return &#39;staticMethod&#39;;\n  };\n\n  Foo.prototype.prototypeMethod = function () {\n    return this.prop;\n  };\n\n  return Foo;\n}());\n\nvar foo = new Foo(123);\nconsole.log(foo.prototypeMethod()); // 123\nconsole.log(Foo.staticMethod()); // staticMethod\nconsole.log(foo.staticMethod()); // Uncaught TypeError: foo.staticMethod is not a function</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결론</p>\n<p>정적 메소드인 staticMethod는 생성자 함수 Foo의 메소드(함수는 객체이므로 메소드를 가질 수 있다.)이고, 일반 메소드인 prototypeMethod는 프로토타입 객체 Foo.prototype의 메소드이다. 따라서 staticMethod는 foo에서 호출할 수 없다.</p>\n<h3>클래스 상속</h3>\n<p>클래스 상속은 코드 재사용 관점에서 매우 유용하다. 새롭게 정의할 클래스가 기존에 있는 클래스와 유사하다면, 상속을 통해 그대로 사용하되 다른 점만 구현하면 된다. 코드 재사용은 개발 비용을 현저히 줄일 수 있다.</p>\n<h3>extends</h3>\n<p>extends 키워드는 부모 클래스를 상속받는 자식 클래스를 정의할 때 사용한다. 부모 클래스 Circle을 상속받는 자식 클래스 Cylinder를 정의해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 부모 클래스\nclass Circle {\n  constructor(radius) {\n    this.radius = radius; // 반지름\n  }\n\n  // 원의 지름\n  getDiameter() {\n    return 2 * this.radius;\n  }\n\n  // 원의 둘레\n  getPerimeter() {\n    return 2 * Math.PI * this.radius;\n  }\n\n  // 원의 넓이\n  getArea() {\n    return Math.PI * Math.pow(this.radius, 2);\n  }\n}\n\n// 자식 클래스\nclass Cylinder extends Circle {\n  constructor(radius, height) {\n    super(radius);\n    this.height = height;\n  }\n\n  // 원통의 넓이: 부모 클래스의 getArea 메소드를 오버라이딩하였다.\n  getArea() {\n    // (원통의 높이 * 원의 둘레) + (2 * 원의 넓이)\n    return (this.height * super.getPerimeter()) + (2 * super.getArea());\n  }\n\n  // 원통의 부피\n  getVolume() {\n    return super.getArea() * this.height;\n  }\n}\n\n// 반지름이 2, 높이가 10인 원통\nconst cylinder = new Cylinder(2, 10);\n\n// 원의 지름\nconsole.log(cylinder.getDiameter());  // 4\n// 원의 둘레\nconsole.log(cylinder.getPerimeter()); // 12.566370614359172\n// 원통의 넓이\nconsole.log(cylinder.getArea());      // 150.79644737231007\n// 원통의 부피\nconsole.log(cylinder.getVolume());    // 125.66370614359172\n\n// cylinder는 Cylinder 클래스의 인스턴스이다.\nconsole.log(cylinder instanceof Cylinder); // true\n// cylinder는 Circle 클래스의 인스턴스이다.\nconsole.log(cylinder instanceof Circle);   // true</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">오버라이딩(Overriding)\n상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다.\n\n오버로딩(Overloading)\n매개변수의 타입 또는 갯수가 다른, 같은 이름의 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용해 구현할 수는 있다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>super</h3>\n<p>super 키워드는 부모 클래스를 참조할 때 또는 부모 클래스의 constructor를 호출할 때 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 부모 클래스\nclass Circle {\n...\n}\n\nclass Cylinder extends Circle {\n  constructor(radius, height) {\n    // ① super 메소드는 부모 클래스의 constructor를 호출하면서 인수를 전달한다.\n    super(radius);\n    this.height = height;\n  }\n\n  // 원통의 넓이: 부모 클래스의 getArea 메소드를 오버라이딩하였다.\n  getArea() {\n    // (원통의 높이 * 원의 둘레) + (2 * 원의 넓이)\n    // ② super 키워드는 부모 클래스(Base Class)에 대한 참조\n    return (this.height * super.getPerimeter()) + (2 * super.getArea());\n  }\n\n  // 원통의 부피\n  getVolume() {\n    // ② super 키워드는 부모 클래스(Base Class)에 대한 참조\n    return super.getArea() * this.height;\n  }\n}\n\n// 반지름이 2, 높이가 10인 원통\nconst cylinder = new Cylinder(2, 10);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>참고</p>\n<ul>\n<li><a href=\"https://poiemaweb.com/es6-class\">poiemaweb</a></li>\n</ul>","frontmatter":{"title":"[JavaScript] 클래스(Class) 이해하기","date":"January 12, 2020"},"id":"547f317a-fea4-5f30-9846-15a6849d29d0"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"Your Disqus-short-name here"}}}},"pageContext":{"slug":"/2020-01-12-class/","previous":{"fields":{"slug":"/2020-01-11-prototype/"},"frontmatter":{"title":"[JavaScript] 프로토타입(ProtoType) 이해하기 ","tag":["Posts"],"layout":null}},"next":{"fields":{"slug":"/2020-01-12-this/"},"frontmatter":{"title":"[JavaScript] this 이해하기 ","tag":["Posts"],"layout":null}}}},"staticQueryHashes":["3668704128"]}