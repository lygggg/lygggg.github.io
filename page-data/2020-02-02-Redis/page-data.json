{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-02-02-Redis/","result":{"data":{"markdownRemark":{"html":"<h2>목적</h2>\n<p>로그인 기능을 구현하는 것이 목적이라면 반드시 알아야 할 Redis에 대해서 알아보는 것이 이 글의 목적입니다.</p>\n<h2>Redis란?</h2>\n<p>레디스(Redis)는 “REmote DIctionary System”의 약자로 메모리 기반의 Key/Value Store이며, 리스트, 해시, 셋 정렬된 셋 등 여러 형식의 자료구조를 지원합니다. NoSQL DBMS로 분류되기도 하고, memcached와 같은 In memory 솔루션으로 분리 되기도 합니다. 메모리에 상주하면서 RDBMS의 캐시 솔루션으로서 주로 사용되며 인스타그램, 라인, StackOverflow, 블리자드 등 여러 소셜 서비스에서 사용하는 검증된 오픈소스 솔루션입니다.</p>\n<h2>Redis 특징</h2>\n<h3>Key-Value Store</h3>\n<p>레디스는 기본적으로 Key/Value Store입니다. 특정 키값에 저장하는 구조로 되어 있고 기본적인 PUT/GET Operation을 지원한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 387px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.01550387596899%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABXElEQVQoz52S2U6DQBSGff+30Hhpo/FxtCwFBGphmI2tZfFjMaCJN/4BMjDnX84Z7sZxbJqm7/txxjDjdrtVVSWlNMayuO7AVtd1bdtSfMfNSkoligndDK2U4zjJOWVtrd2Tq7ru+2Ej43x4fn06vNw/PHqezx5u1pbQyrLS2lCTX7LP7DIXt13Xo7KSqRCiCMLg6LpCCLSMMXBKNuoJRG3bNfNvZ4qoTtI4ihOtNLa0mmVZkqZ13Rg7tU2NVIonX65XuDtnuvV89+3o4EyfECjFXM5gnKUt/VNQN1OKZQqbs7UmTeMwivNczMOTyTkOwhAfGlfKVOVkjiCm8DHfyLKQ/sk/Op5SClU7OxdyMucahu4UYdvA5CCXA1rJyAMmgUlV1cQm5/LERGtNZuKgyJrv8H8cFQMcv8FrLgQqaCH7EUXvjot0OYMgiG5kcpJo/w/Br//G0vZK/je+AI12sv4s6PAJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"redis\" title=\"redis\" src=\"/static/d5ce19b33773e370c502ef9ce4eedda0/691c3/redis.png\" srcset=\"/static/d5ce19b33773e370c502ef9ce4eedda0/158c9/redis.png 155w,\n/static/d5ce19b33773e370c502ef9ce4eedda0/5fad2/redis.png 310w,\n/static/d5ce19b33773e370c502ef9ce4eedda0/691c3/redis.png 387w\" sizes=\"(max-width: 387px) 100vw, 387px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<p>이 모든 데이터는 메모리에 저장되고, 이로 인하여 매우ㅎ 빠른 읽기 쓰기 속도가 보장됩니다. 그래서 전체 저장 가능한 데이터 용량은 물리적인 메모리 크기를 넘어설 수 있습니다. 장점은 익히기 쉽고 직관적입니다. 단점은 Key/Value 형태로 저장된 데이터를 레디스 자체 내에서 처리하는 것이 어렵다는 점입니다.</p>\n<h3>다양한 데이터 타입</h3>\n<p>단순한 메모리 기반의 Key/Value라면 이미 memcached가 있습니다. 그렇지만 어떤 차이 때문에 redis가 유행하는 것일까요?\nredis가 Key/Value Store 이기는 하지만 저장되는 Vlaue가 단순한 Object가 아니라 자료구조를 갖기 때문입니다. redis가 지원하는 데이터 형은 크게 아래와 같이 5가지로 나눌 수 있습니다.</p>\n<ol>\n<li>String</li>\n<li>일반적인 문자열로 최대 512mbyte 길이까지 지원한다. Text 문자열뿐만 아니라 Integer와 같은 숫자나 JPEG 같은 Binary File까지 저장할 수 있다.</li>\n<li>Set</li>\n<li>set은 String의 집합이다. 여러 개의 값을 하나의 Value 내에 넣을 수 있다고 생각하면 되며 블로그 포스트의 태그(Tag) 등에 사용될 수 있다. 재미있는 점은 set 간의 연산을 지원하는데, 집합인 만큼 교집합, 합집합, 차이(Differences)를 매우 빠른 시간 내에 추출할 수 있다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 380px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAw0lEQVQY05WOXw+CIBTF/f6fy7VRb+VApZkimtMAQd3MP9RVHnqqrfPA7oHzOxdPSXkJguc0vf6XxxjDGCvVCiHuZfkQYhiGvu+NMeM4Wmt/wZxzCLVtG5zPB9/HYQgY2LqupZTzPK+73ABNzi7Lslrr5Xnu0iEhJ4RiSruu01o3TQMn9LIsS29pkiQZYwVnMMATiUIh5QZDGmCC8RGhiF4dXO+CDfA9u2vb/NF26UEC0kZraKE05kWxWWOUUlVVOfib3pq0VORvXdwQAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"set\" title=\"set\" src=\"/static/226d421da276054c1144af10b70a2247/3f520/set.png\" srcset=\"/static/226d421da276054c1144af10b70a2247/158c9/set.png 155w,\n/static/226d421da276054c1144af10b70a2247/5fad2/set.png 310w,\n/static/226d421da276054c1144af10b70a2247/3f520/set.png 380w\" sizes=\"(max-width: 380px) 100vw, 380px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<ol start=\"3\">\n<li>Sorted Set</li>\n<li>set에 “score”라는 필드가 추가된 데이터 형으로 score는 일종의 “가중치” 정도로 생각하면 된다. sorted set에서 데이터는 오름차순으로 내부 정렬되며, 정렬이 되어있는 만큼 score 값 범위에 따른 쿼리, top Rank에 따른 query 등이 가능하다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 363px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 31.40495867768595%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA5ElEQVQY042Q22qEMBCGff8X2yLbTaKL3SWJmsQkuvGAYCue4s5i6U2hdC6GGfi/fw5B17bJ9XqnNM3zW5IMn1/7vnvv939EIKWICEIYU8YJwdaWbdO42vV9P47juq4/0t+OgS1tUSiELnUDVMMofTudwjDUWtd1PQzDgb1cvD94D9X+KgJjjJKSEPJwrizLlKcYIWitNV3XmaLIcsE5Y5xZY4RUSslC6+T2Ab7fMMYY4KqqUs4v53e4wlrrnAMFzJzneVmWIx8xTdO2bQGIlBBxHB1wnmURIXEUV48KfGHzP/73BHIkTgPWmSAtAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sorted\" title=\"sorted\" src=\"/static/4548f332e7d7f55ee15669d01a6bb6ee/4e786/sorted.png\" srcset=\"/static/4548f332e7d7f55ee15669d01a6bb6ee/158c9/sorted.png 155w,\n/static/4548f332e7d7f55ee15669d01a6bb6ee/5fad2/sorted.png 310w,\n/static/4548f332e7d7f55ee15669d01a6bb6ee/4e786/sorted.png 363w\" sizes=\"(max-width: 363px) 100vw, 363px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<ol start=\"4\">\n<li>Hashes</li>\n<li>hash는 value 내에 field/string value 쌍으로 이루어진 테이블을 저장하는 데이타 구조체이다. RDBMS에서 PK 1개와 string 필드 하나로 이루어진 테이블이라고 이해하면 된다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 167px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.06586826347305%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACD0lEQVQoz5VR2ZKaUBDl/5/zMF+QpKZmySSjYXABHQEVdURk3wTEpdzFpYoI5BBTk6dUKl334dzeTvdpIsvSNE2yX3a5XLL/MSJL46enh8evBbpK39x8YBj6+bloWu61V/p3S5KEyLJE07XPHz/dPzxSFMlUK7e3d7JmohjxfzBLkjSZTObz+XQyWSyXq9VqPpsHQTAajRRFMQwDwHXdcRhO8GBh6DiO7/v9fp9A4NpGU1W2UWNpWrOCqweZURQBYELX1uul+kBSVF1P0zwKVoJhGNSbpilJw0a9Vq/Vev0BvmjPcZwoirbjmIbRarLUS5lhaizHGYYJZpIkidfXVwzp+x7KStRLlaL4VtcdjRBut9uyLAOg/q3XrZLldqfbbLXQF0OVSqV859PpFB0isNXpSpUqDVXrcDgcj0csjCSA3Xbb7fCFL98rFbrZFvb7KI5jtCYwGBbbbreObYFk7PtBEG42Gzg1TRuPx/v9fr1eLxaL0AuWqxxA1PP5zPM8Ydv2VR7LNCsUWS4W3wULw3C32wH8iONBX/h2X2DqbKvTSZL0t2AsyyLJ8zxd1zCnZRiabuALpyAIuFYQjD0vv1Yeta2Rm+PZbFYul/+cCsxNvsExjO3Nrp7pdPp+KttUaJIRB7KiqtdozoxbgwTbOrYjvvVgYIb+2HY4HEJFANxCliWhJXSETl8UkYy+EOwnvAau/44OzUsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hash\" title=\"hash\" src=\"/static/353f19397e8b6691abfabb96b0f28c79/21521/hash.png\" srcset=\"/static/353f19397e8b6691abfabb96b0f28c79/158c9/hash.png 155w,\n/static/353f19397e8b6691abfabb96b0f28c79/21521/hash.png 167w\" sizes=\"(max-width: 167px) 100vw, 167px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<ol start=\"5\">\n<li>List</li>\n<li>list는 string들의 집합으로 저장되는 데이터 형태는 set과 유사하지만, 일종의 양방향 Linked list라고 생각하면 된다. List 앞과 뒤에서 PUSH/POP 연산을 이용해서 데이터를 넣거나 뺄 수 있고, 지정된 Index값을 이용하여 지정된 위치에 데이터를 널거나 뺄 수 있다.</li>\n</ol>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 412px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 37.13592233009708%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA50lEQVQY032Q226DMBBE/f8fF1WpokbQioDwpaZcfQ8Id2yivETtebC0453dsclXWZ5ObzHGfd9xhhCmaZrn2RijtGKMMsaHYeCCN03DOaeUim8pZYdmUt9udd0opaC2bUsz6IY/ZJxz67o67621PhPCXWudzEKI4D2Kz7K4XD6wEE1DBjoKKMuyOGeNNRhxlDFDGGNKJ8oimXGBFHCO44i1nexYisKkFIxz2f0IzhHveCPBTTYsxfV6Pr8vmb7voSNC/BeCGC6D5QhZVRUUPAzKtm3HR77yMD/HbBlERez0Q849m/7iF9Tfj0m0xbFuAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"list\" title=\"list\" src=\"/static/6406c21df407a3ed23137d33ee35a860/9e32a/list.png\" srcset=\"/static/6406c21df407a3ed23137d33ee35a860/158c9/list.png 155w,\n/static/6406c21df407a3ed23137d33ee35a860/5fad2/list.png 310w,\n/static/6406c21df407a3ed23137d33ee35a860/9e32a/list.png 412w\" sizes=\"(max-width: 412px) 100vw, 412px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<h3>Persistence</h3>\n<p>Redis는 데이터 disk에 저장할 수 있습니다. 따라서 Redis는 서버가 shutdown된 후에 restart하더라도 disk에 저장해 놓은 데이터를 다시 읽어서 데이터가 유실되지 않습니다. redis의 데이터를 disk에 저장하는 방식은 snapShot,AOF 방식이 있습니다.</p>\n<ul>\n<li>snapShot : 스냅샷은 RDB에서도 사용하고 있는 어떤 특정 시점의 데이터를 DISK에 옮겨 담는 방식을 뜻합니다. Blocking 방식의 SAVE와 Non-blocking 방식의 BgGSAVE 방식이 있습니다.</li>\n<li>AOF : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태입니다. 서버가 재시작 할 시 write/update를 순차적으로 재실행, 데이터를 복구합니다.</li>\n</ul>\n<p>레디스 공식 문서에서의 권장사항은 RDBMS의 rollback 시스템같이 두 방식을 혼용해서 사용하는 것입니다. 주기적으로 snapShot으로 백업하고 다음 snapShot까지의 저장을 AOF 방식으로 수행하는 것이죠.</p>\n<h3>ANSI C로 작성</h3>\n<p>C언어로 작성되어 Java와 같이 가상머신 위에서 동작하는 언어에서 발생하는 성능 문제에 대해 자유롭습니다. 곧바로 기계어로 동작하지 않고 어떤 가상의 머신 위에서 인터프리터 된 언어로 가동하는 경우에는 가비지 컬렉션(Garbage Collection) 동작에 따른 성능 문제가 발생할 수밖에 없습니다. 하지만 C언어로 작성된 Redis는 이런 이슈에서 자유롭다.</p>\n<h3>Redis 아키텍처</h3>\n<h4>Redis Topology</h4>\n<p>레디스는 아래 그림과 같이 Master-slave 형태로 데이터를 복제해서 운영할 수 있습니다. 이 master-slave간의 복제는 non-blocking 상태로 이루어집니다.</p>\n<h4>Redis Sharding</h4>\n<p>레디스에서 데이터를 샤딩하여 레디스의 read 성능을 높일 수 있습니다. 예를 들어 #1~#999, #1000~#1999 ID 형태로 데이터를 나누어서 데이터의 용량을 확장하고 각 서버에 있는 Redis의 부하를 나누어 줄일 수 있습니다.</p>\n<h4>Redis Cluster</h4>\n<p>레디스는 이전에는 Clustering을 지원하지 않았지만 Clustering을 지원하면서 대부분의 회사가 Redis를 클러스터로 묶어서 가용성 및 안정성 있는 캐시 매니저로써 사용하고 있습니다. Single Instance로서 레디스를 사용할 때는 Sharding이나 Topolgy로서 커버해야 했던 부분을 Clustering을 이용함으로써 어플리케이션을 설계하는 것이 더 수월해졌다고 볼 수 있습니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 620px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.362637362637365%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABX0lEQVQoz42R7W6DMAxF+/5POKZ2ZTDafBECAUKhlB0C06r+2VCEHMcn1745zPPjfp9/1hqT6ftQOfeVF9eLcK72vn2q2Rdlh1d4mh+PpSxtWZZaayllXddKqf/BMVtVro1f0zR937Plxj/hVbaumyzLEey6znvPvygK+JfKVxiS8YwxWZYJIeictq21p9PH9So4etbfYRZZVtf1kOM4hTAQAwgh27bDv2m6G1MSb8UbdYhMsLbiLHlLpFRUQMbmszzPcZstSwiVJO+YxwhsV3hZFjYI0h724pDWBkFmNvEjQwMwzK/iFLFGz/OywohQyplzDm/pAp6gjt8wBKU0899uAwVN40MIvOWuDFxV1QbzJ+YMDIXtUm1gLS8X4YYMAr9tA3AfpQjSKn0SUE0deYzDi3EcIVc/+p5e9rZxSOsyTbP0/IltUdIbvT7Y+ZzixpaRQh6PH5eLKI31TYvyN7KsrWmLZXvrAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"arc\" title=\"arc\" src=\"/static/c7d303d10d61875810f1c260bf40f562/2a195/arc.png\" srcset=\"/static/c7d303d10d61875810f1c260bf40f562/158c9/arc.png 155w,\n/static/c7d303d10d61875810f1c260bf40f562/5fad2/arc.png 310w,\n/static/c7d303d10d61875810f1c260bf40f562/2a195/arc.png 620w,\n/static/c7d303d10d61875810f1c260bf40f562/cecac/arc.png 728w\" sizes=\"(max-width: 620px) 100vw, 620px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<h2>사용 시 주의할 점</h2>\n<h4>장애가 났을 경우 그에 대비한 운영 플랜이 세워줘야 함</h4>\n<p>Redis는 인 메모리 데이터 저장소라서 서버가 장애가 났을 경우 데이터 유실이 발생합니다. 따라서 위에서 이야기한 snapShot, AOF 기능을 통한 복구 시나리오가 제대로 세워져 있어야 데이터 유실에 대비한 사고에 대처할 수 있습니다.</p>\n<h4>캐시 솔루션으로 사용할 시 잘못된 데이터가 캐시되는 것을 방지, 예방해야 함</h4>\n<p>레디스와 캐싱하고자 하는 데이터 저장소의 데이터가 서로 일치하는지 주기적인 모니터링과 이를 방지하기 위한 사내 솔루션을 개발하는 것이 좋습니다.</p>","frontmatter":{"title":"레디스(Redis)란? 무엇인가.","date":"February 02, 2020"},"id":"0fdafd5f-9628-580c-a40a-700cca5bae23"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"disqus_93JVYbBpDP"}}}},"pageContext":{"slug":"/2020-02-02-Redis/","previous":{"fields":{"slug":"/2020-01-19-regularExpression/"},"frontmatter":{"title":"자바스크립트 정규표현식에 대해서 알아보자.","tag":["Posts"],"layout":null}},"next":{"fields":{"slug":"/2020-02-09-recursive/"},"frontmatter":{"title":"재귀함수란? 간단하게 알아보자.","tag":["Posts"],"layout":null}}}},"staticQueryHashes":["3668704128"]}