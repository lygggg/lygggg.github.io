{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-07-06-deepCopy/","result":{"data":{"markdownRemark":{"html":"<h2>깊은 복사에 대해 얼마나 알고있을까?</h2>\n<p>제가 자바스크립트에 관한 책을 읽으면 항상 언급되는 것이 깊은복사에 대한 문제였습니다. 그만큼 중요하다고 생각하고, 제가 공부한 것들을 블로그에 정리해보려고 합니다.</p>\n<p>여태까지 깊은 복사를 공부하려고 관련 블로그 글들을 접했을 때에는 자바스크립트에서 제공하는 JSON.stringify 같은 방법들이 깊은 복사에 대한 문제들을 문제없이 해결해준다고 생각했습니다. 그리고 이렇게 알고있었던 것을 반성하며 글로 정리해보려고 합니다.</p>\n<h2>복사를 하기 위한 다양한 방법들</h2>\n<p>아래부터는 다양한 복사 방법들을 보고 이글에서 언급했던 깊은복사에 대해서 생각하면서 몇가지 질문들을 가지고 글을 읽으시면 더 좋을 것 같습니다.</p>\n<ul>\n<li>복사된 객체의 참조 주소와 기존의 객체의 참조 주소가 다른가요?</li>\n<li>어떠한 타입도 문제없이 복사할 수있나요?</li>\n<li>객체 안에 객체가있는 상황이 반복되어도 기존 객체의 참조 주소와 다른가요?</li>\n</ul>\n<h3>Spread Operator</h3>\n<p>Spread 연산자는 편하고 실제도로 객체를 복사할 떄 많이 쓰는 방법입니다.</p>\n<p>기본적으로 Spread 연산자를 사용하기 위해서는 해당 객체에 <code class=\"language-text\">[Symbol.iterator]</code> 프로퍼티가 존재해야 합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52567149/177507220-318b8b1a-5493-4e40-ba98-48c338e29439.png\" alt=\"iterator\"></p>\n<p>간단하게 Spread 연산자의 사용법에 대해서 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const arr = [1, 2, 3, 4];\nconst copyArr = [...arr];\nconsole.log(copyArr) // [1, 2, 3, 4]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 코드를 실행하면 arr 배열을 copyArr에 복사할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const arr = [1, 2, 3, 4];\nconst copyArr = [...arr];\narr[Symbol.iterator] = null;\nconsole.log(copyArr) // [error] arr is not iterable</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 위에서 언급했듯이 <code class=\"language-text\">[Symbol.iterator]</code>를 삭제한다면 위와 같은 에러가 발생하지만 다른 문제가 없다면 안전하게 배열을 복사하는 것을 볼 수 있습니다. 그러나 이러한 복사는 치명적인 문제가 존재합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const arr = [1, 2, 3, 4, [1, 2]];\nconst copyArr = [...arr];\ncopyArr.push(5);\ncopyArr[4].push(3);\nconsole.log(copyArr); // [1, 2, 3, 4, [1, 2, 3], 5]\nconsole.log(arr); // [1, 2, 3, 4, [1, 2, 3]]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드를 보면 문제점을 찾을 수 있습니다. copyArr에 5를 push했을경우 두 배열의 참조 주소가 다르기 때문에 copyArr에만 5가 들어가지만, arr에는 없는 것을 확인할 수 있습니다. 하지만 copyArr 4번째 인덱스에 있는 배열에 푸쉬했을 경우 기존의 arr에도 값이 들어가있는 것을 확인할 수 있습니다.</p>\n<p>바로 위에서 언급했던 질문중에 <code class=\"language-text\">객체 안에 객체가있는 상황이 반복되어도 기존 객체의 참조 주소와 다른가요?</code> 의 경우에 맞지않습니다. 기존 arr 값들을 하나씩 옮겨담는 작업을 하기 떄문에 즉 Spread 연산자를 사용한 복사는 depth가 1이 넘어가는 객체를 깊은복사 할 수 없기때문에 이 방법은 얇은 복사라고 할 수 있습니다.</p>\n<h3>Array.prototype.slice</h3>\n<p>slice 메소드를 사용하는 방법의 문제점도 위에서 언급했던 Spread 연산자의 문제점과 같습니다. 기존의 배열에서 자르고 싶은 부분을 복사할 수 있는 메서드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const arr = [1, 2, 3, 4, [1, 2]];\nconst copyArr = arr.slice(); // [1, 2, 3, 4, [1, 2]]\ncopyArr.push(5);\ncopyArr[4].push(3);\nconsole.log(copyArr); // [1, 2, 3, 4, [1, 2, 3], 5]\nconsole.log(arr); // [1, 2, 3, 4,[1, 2, 3]]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위에서 언급했던 문제와 동일하게 depth가 1이 넘어가는 객체를 깊은복사 할 수 없기 때문에 얇은 복사라고 할 수 있습니다.</p>\n<h3>Object.assign</h3>\n<p>자바스크립트에서 제공하는 Object,assign()을 사용하면 객체의 모든 데이터들을 복사해 대상 객체에 붙여넣을 수 있습니다. 하지만 이러한 방법도 위에서 제시한 문제들을 해결할 수 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const object = {\n    test: 1,\n    testObject: {\n        a: 2,\n        b: 3,\n    },\n};\n\nconst copyObj = Object.assign({}, object);\n\ncopyObj.testObject.a = 4;\nconsole.log(object.testObject); // {a: 4, b: 3}\nconsole.log(copyObj.testObject); // {a: 4, b: 3}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>복사한 copyObj.testObject안의 a를 변경했을시 기존 object의 a 또한 변경되는 모습을 볼 수 있습니다. 그러므로 이 방법 또한 얇은 복사라고 할 수 있습니다.</p>\n<blockquote>\n깊은 클로닝에 대해서, Object.assign() 은 속성의 값을 복사하기때문에 다른 대안을 사용해야합니다. 출처 값이 객체에 대한 참조인 경우, 참조 값만을 복사합니다.\n</blockquote>\n<h3>JSON.stringify</h3>\n<p>JSON.stringify 을 사용한 방법은 깊은 복사에 대해 깊게 공부하기 전까지 정말 좋은 방법이라고 생각하고있었고, 필자도 자주 사용했던 방법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const object = {\n    test: 1,\n    testObject: {\n      a: 2,\n      b: 3,\n    },\n  };\n\n  const copyObj = JSON.parse(JSON.stringify(object));\n  copyObj.testObject.a = null;\n  console.log(copyObj.testObject); // {a: null, b: 3}\n  console.log(object.testObject); // {a: 2, b: 3}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위에 언급했던 얇은 복사 방법들과는 다르게 JSON.stringify를 사용한 복사는 <code class=\"language-text\">객체 안에 객체가있는 상황이 반복되어도 기존 객체의 참조 주소와 다른가요?</code> 에 대한 질문에 만족할 수 있는 방법입니다. 이렇게 될수있는 원리를 알아보면 JSON.stringify는 객체를 string 문자열로 변경해주는 역할을 하고, JSON.parse는 문자열을 다시 객체로 변경해주는 역할을 하기 때문입니다.</p>\n<p>자바스크립트에서 string, number같은 기본형타입은 불변성(Immutable)을 가진 타입이고, 기본형 타입을 제외한 모든 타입 즉 객체타입은 가변성(mutable)을 가진 타입이기 떄문입니다. 그렇기 떄문에 문자열로 변경하는 작업에서 이전 객체에서의 참조가 없어지는 원리를 이용한 방법입니다.</p>\n<h3>그렇다면 JSON.stringify는 아무런 문제점이 없는 방법인가요?</h3>\n<p>JSON.stringify를 이용한 방법에도 문제점이 존재합니다. 바로 JSON에서 허용하는 데이터 포맷이 아닌경우에는 정상적으로 데이터를 복사할 수 없습니다.</p>\n<p>JSON에서 허용하는 데이터 포맷은 아래와 같습니다.</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Array</li>\n<li>Object</li>\n<li>null</li>\n</ul>\n<p>예를들면 객체안의 함수나 메소드, 정규표현식, Symbol, Date, Infinity, Map, Set, BigInt등을 복사할 수 없습니다.</p>\n<h3>저 위에 언급한 것들도 자바스크립트에서는 객체(Object) 아닌가요?</h3>\n<p>맞습니다 실제로 Map, Set 는 타입을 검사해도 Object가 나옵니다. 실제로 저도 같은 생각을 가지고 있었습니다. 그리고 알아본 결과로는 Object.prototype.toString.call를 사용해서 나오는 2번쨰 값이 Object일 경우에만 허용하는 것을 확인할 수 있었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">console.log(Object.prototype.toString.call(new Set())); // [object Set]\n  console.log(Object.prototype.toString.call(new Map())); // [object Map]\n  console.log(Object.prototype.toString.call(function () { })); // [object Function]\n  console.log(Object.prototype.toString.call(BigInt)); // [object Function]\n  console.log(Object.prototype.toString.call({})); // [object Object]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>평균적으로 다른 방법들보다 속도면에서 느리다는 단점이 있습니다.</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52567149/177692595-62767319-5e15-45b7-8704-4090743adecb.png\" alt=\"deepcopytest\"></p>\n<p><a href=\"https://jsben.ch/rmgqP\">https://jsben.ch/rmgqP</a>\n첫번째는 재귀를 사용한 복사, 두번째는 lodash, 세번째는 JSON.stringify를 사용하고 나온 성능 테스트 결과입니다.</p>\n<h3>직접 함수를 구현하는 방법</h3>\n<p>직접 깊은복사를 하는 함수를 구현하는 방법이 있습니다. 이 방법은 재귀를 사용한 방법이고, 제가 제시했던 3가지 문제점들을 해결해 줄 수 있습니다.</p>\n<p>아래 코드는 따로 처리가 필요한 타입들을 따로 객체에 저장해서 객체일시 재귀를 반복하고 아닐경우 값을 리턴함으로써 깊은복사가 되도록 구현한 코드입니다. 정답이 아니며 더 좋은 방법이 있을수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const checkType = (target) =&gt; {\n  const CONSTRUCTOR_TYPE = {\n    &quot;[object Array]&quot;: copyArray,\n    &quot;[object Object]&quot;: copyObject,\n    &quot;[object Map]&quot;: copyMap,\n    &quot;[object Set]&quot;: copySet,\n    &quot;[object Date]&quot;: copyDate,\n    &quot;[object RegExp]&quot;: copyRegExp,\n  };\n  const type = Object.prototype.toString.call(target);\n  return CONSTRUCTOR_TYPE[type];\n};\n\nconst copyObjectDeep = (target) =&gt; {\n  const isObject = checkType(target);\n  if (isObject) return isObject(target);\n  return target;\n};\n\nfunction copyObject(target) {\n  const result = {};\n  for (let key of Object.keys(target)) {\n    result[key] = copyObjectDeep(target[key]);\n  }\n  return result;\n}\n\nfunction copyArray(target) {\n  const result = [];\n  for (let index in target) {\n    result[index] = copyObjectDeep(target[index]);\n  }\n  return result;\n}\n\nfunction copyMap(target) {\n  const result = new Map();\n  target.forEach((value, key) =&gt; result.set(key, copyObjectDeep(value)));\n  return result;\n}\n\nfunction copySet(target) {\n  const result = new Set();\n  target.forEach((prop) =&gt; result.add(copyObjectDeep(prop)));\n  return result;\n}\n\nfunction copyRegExp(target) {\n  return new RegExp(target.source, target.flags);\n}\n\nfunction copyDate(target) {\n  return new Date(target.getTime());\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드가 성공적으로 깊은 복사를 수행할 수 있는지 테스트코드 또한 작성해볼 수 있습니다. 재귀로 구현한 함수를 테스트하기 위해서 재귀를 사용하는 방법으로 불변성까지 테스트하도록 작성했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const obj = {\n  bigInt: BigInt(1),\n  date: Date(),\n  string: &quot;ss&quot;,\n  number: 123,\n  reg: new RegExp(&quot;ab/c&quot;),\n  isNaN: 123 / &quot;a&quot;,\n  infinity: 123 / 0,\n  arr: [1],\n  undefined: undefined,\n  null: null,\n  symbol: Symbol(1),\n  obj1: {\n    obj2: {\n      test: 100,\n      obj3: [1, 2, 3],\n    },\n  },\n  fun: function () {\n    return 100;\n  },\n};\n\ntest(&quot;객체 안에 객체안에 객체가 있어도 복사할 수 있다.&quot;, () =&gt; {\n  const copyObj = copyObjectDeep(obj);\n  expect(copyObj.obj1.obj2.test).toEqual(100);\n});\n\ntest(&quot;Map,Set를 복사할 수 있다.&quot;, () =&gt; {\n  const map = new Map();\n  map.set(1, &quot;a&quot;);\n  const set = new Set();\n  set.add(&quot;응애&quot;);\n  expect(copyObjectDeep(map)).toEqual(map);\n  expect(copyObjectDeep(set)).toEqual(set);\n});\n\ntest(&quot;객체 안에 배열을 복사할 수 있다.&quot;, () =&gt; {\n  const copyObj = copyObjectDeep(obj);\n  expect(copyObj.obj1.obj2.obj3).toEqual([1, 2, 3]);\n});\n\ntest(&quot;객체에 함수를 복사할 수 있다.&quot;, () =&gt; {\n  const copyObj = copyObjectDeep(obj);\n  expect(copyObj.fun()).toBe(100);\n});\n\ntest(&quot;객체에 Date객체, 정규표현식, Infinity등을 복사할 수 있다.&quot;, () =&gt; {\n  const copyObj = copyObjectDeep(obj);\n  expect(copyObj).toEqual(obj);\n});\n\ntest(&quot;객체의 불변성을 테스트한다.&quot;, () =&gt; {\n  const copyObj = copyObjectDeep(obj);\n  const recursiveDeepTest = (obj, copyObj) =&gt; {\n    for (let key in obj) {\n      if (typeof obj[key] === &quot;object&quot; &amp;&amp; obj[key] !== null) {\n        expect(obj[key] === copyObj[key]).toBe(false);\n        recursiveDeepTest(obj[key], copyObj[key]);\n      }\n    }\n  };\n  recursiveDeepTest(obj, copyObj);\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<script src=\"https://gist.github.com/lygggg/542037096598bb531e6dcef100b34b1b.js\"></script>\n<p><img src=\"https://user-images.githubusercontent.com/52567149/177704550-674f6a27-5a6f-4d79-8945-cc5767e4c413.png\" alt=\"deepjest\"></p>\n<p>테스트가 성공적으로 수행되는 것을 볼 수 있습니다.</p>\n<h3>Lodash</h3>\n<p>마지막으로는 많은 사람들이 흔히 사용하는 Lodash를 이용하여 깊은 복사를 하는 방법이 있습니다. 팀원들끼리 합의를 했거나, 이미 프로젝트에서 사용중이라면 사용을 고려해볼 수 있습니다.</p>\n<p>Lodash cloneDeep을 사용하면 위에서 언급한 모든것을 만족하는 결과를 얻을 수 있습니다. 아래코드에서 간단하게 사용법만 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const _ = require(&#39;lodash&#39;);\n\nconst obj = {\n  string: &quot;ss&quot;,\n  number: 123,\n  reg: new RegExp(&quot;ab/c&quot;),\n  isNaN: 123 / &quot;a&quot;,\n  infinity: 123 / 0,\n};\n\nconst copyObj = _.cloneDeep(obj);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>결론</h2>\n<p>자바스크립트에서는 객체를 복사하는 다양한 방법이 존재한다. Spread Operator, Array.prototype.slice, Object.assign는 깊은 복사를 지원하지 못하고, JSON.stringify는 깊은복사를 지원하지만 JSON 타입에 맞지않는 유형이 있다면 복사를 못하는 문제점이 있기 떄문에 조심해야한다.</p>\n<p>결국 상황에 맞는 방법을 사용하는 것이 최고라고 생각한다. 특정한 상황에서는 위에 언급한 방법들이 최선의 방법이 될수도 있다. 예를들면 알고리즘 문제를 풀떄 간단한 배열, string, number만 저장하는 객체라면 얇은 복사, JSON.stringify를 사용하는 것도 좋은 방법이 될 수 있다. 그런 것이 아니라면 직접 구현하거나 lodash같은 라이브러리를 사용하는 것을 고려해보자.</p>\n<p>객체의 불변성은 어디서나 언급될 정도로 중요한 문제지만 무조건은 없다고 생각한다. 객체가 무거운 상황이거나, 생명주기가 짧은경우, 상태를 공유하는 상황일때 가변으로 설계를 고려하는 것도 좋은 대안 될 수도 있다.</p>","frontmatter":{"title":"깊은 복사에 대해 얼마나 알고있을까?","date":"July 06, 2022"},"id":"4b8a7ff5-7f22-573a-9033-101604bb972d"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"lyg"}}}},"pageContext":{"slug":"/2022-07-06-deepCopy/","previous":{"fields":{"slug":"/2022-07-06-deepCopy/"},"frontmatter":{"title":"깊은 복사에 대해 얼마나 알고있을까?","tag":["JavaScript"],"layout":null}},"next":{"fields":{"slug":"/2022-07-06-deepCopy/"},"frontmatter":{"title":"깊은 복사에 대해 얼마나 알고있을까?","tag":["JavaScript"],"layout":null}}}},"staticQueryHashes":["3668704128"]}