{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-01-12-this/","result":{"data":{"markdownRemark":{"html":"<h2>목적</h2>\n<p>대표적으로 JAVA 같은 객체지향 언어에서의 this는 클래스 인스턴스의 레퍼런스 변수입니다. 하지만 javacript에서 this는 전혀 다른 의미를 가집니다. this가 어려운 이유는 자바스크립트에서 this는 전혀 다른 의미를 가지기 때문입니다. 이 글은 공부를 목적으로 정리한 글입니다.</p>\n<h2>this란?</h2>\n<h3>this는 현재 실행 문맥이다.</h3>\n<p>“실행 문맥”이란 말은 호출자가 누구냐는 것과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">alert(this === window) //true, 호출자는 window\n\nconst caller = {\n    f: function() {\n        alert(this === window)\n    },\n}\ncaller.f() // false, 호출자는 caller 객체</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>평상시의 this는 window를 가리킵니다.\n첫 번째 alert는 window.alert() 즉 window 객체의 메소드 호출이기 때문에 호출자는 window이고 두 번째는 caller 객체의 호출입니다. 다만 strict-mode에서는 전역 객체냐 일반 객체냐에 따라 함수 내부의 this의 결과가 차이가 있습니다. 이 문제는 window를 함수 호출 앞에 붙여주면 해결됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function nonStrictMode() {\n  return this\n}\n\nfunction strictMode() {\n  &#39;use strict&#39;\n  return this\n}\n\nconsole.log(nonStrictMode()) // window\nconsole.log(strictMode()) // undefined\nconsole.log(window.stricMode()) //window</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>생성자 함수 / 객체에서는 어떻게 쓰이나?</h3>\n<p>생성자에는 우리가 제일 싫어하는 this가 많이 나옵니다. 여기서 생성자 함수도 함수입니다. 생성자는 new로 객체를 만들어 사용합니다. 만약에 new로 호출하지 않고 그냥 호출을 하게 되면 어떻게 될까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function NewObject(name, color) {\n    this.name = name\n    this.color = color\n    this.isWindow = function() {\n        return this === window\n    }\n}\n\nconst newObj = NewObject(&#39;nana&#39;, &#39;yellow&#39;)\nconsole.log(newObj.name) // error\nconsole.log(newObj.color) // error\nconsole.log(newObj.isWindow()) // error\n\n\nconst newObj2 = new NewObject(&#39;didi&#39;, &#39;red&#39;)\nconsole.log(newObj2.name) // didi\nconsole.log(newObj2.color) // red\nconsole.log(newObj2.isWindow()) // false</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>new를 붙이지 않고 그냥 호출하면 어떻게 될까요? 위에서 그냥 함수에서 this가 window를 가리킨다고 말했습니다. 이렇게 되면 각 property를 가져올 수 없게 됩니다. 생성자 함수가 아닌 일반 객체에서는 어떨까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const person = {\n  name: &#39;john&#39;,\n  age: 15000,\n  nickname: &#39;man from earth&#39;,\n  getName: function() {\n    return this.name\n  },\n}\nconsole.log(person.getName()) //john\n\nconst otherPerson = person\northerPerson.name = &#39;chris&#39;\nconsole.log(person.getName()) // chris\nconsole.log(otherPerson.getName()) //chris</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>생성자 함수와 크게 다르지 않습니다. 한 가지 볼 점은 otherPerson.name을 chris로 설정한 뒤 person.getName()을 호출하면 출력 결과는 chris로 변경됩니다. 이유는 otherPerson은 person의 레퍼런스 변수이므로 하나를 변경하면 다른 하나도 변경됩니다. 이를 피하기 위해 Object.assign() 메서드를 이용하여 완전히 별도의 객체로 만들어야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">const person = {\n  name: &#39;john&#39;,\n  age: 15000,\n  nickname: &#39;man from earth&#39;,\n  getName: function() {\n    return this.name\n  },\n}\nconst newPerson = Object.assign({}, person)\nnewPerson.name = &#39;chris&#39;\nconsole.log(person.getName()) // john\nconsole.log(newPerson.getName()) // chris</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>bind, arrow function</h3>\n<p>이번에는 생성자 함수 안에서 또 다른 함수가 있는 경우를 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function Family(firstName) {\n  this.firstName = firstName\n  const names = [&#39;bill&#39;, &#39;mark&#39;, &#39;steve&#39;]\n  names.forEach(function(lastName, index) {\n    console.log(lastName + &#39; &#39; + this.firstName)\n    console.log(this)\n  })\n}\nconst kims = new Family(&#39;kim&#39;)\n// bill undefined\n// window\n// mark undefined\n// window\n// steve undefined\n// window</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Family 생성자 함수 안에서 forEach 메서드를 호출합니다. undefined가 출력되는 이유는 forEach 메서드의 서브루틴은 호출될 때 forEach의 context(this)로 바인드 되지 않습니다. 바인드가 안되었다는 것은 전역이라는 것이고 실행 문맥이 전역이라는 말은 this가 window라는 것입니다.</p>\n<p>이 문제를 해결하기 위해서는 this를 that이라는 변수에 저장하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function Family(firstName) {\n  this.firstName = firstName\n  const names = [&#39;bill&#39;, &#39;mark&#39;, &#39;steve&#39;]\n  const that = this\n  names.forEach(function(value, index) {\n    console.log(value + &#39; &#39; + that.firstName)\n  })\n}\nconst kims = new Family(&#39;kim&#39;)\n// bill kim\n// mark kim\n// steve kim</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또 다른 방법은 bind라는 메서드를 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function Family(firstName) {\n  this.firstName = firstName\n  const names = [&#39;bill&#39;, &#39;mark&#39;, &#39;steve&#39;]\n  names.forEach(\n    function(value, index) {\n      console.log(value + &#39; &#39; + this.firstName)\n    }.bind(this)\n  )\n}\nconst kims = new Family(&#39;kim&#39;)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또는 ES6 화살표 함수(arrow function)를 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function Family(firstName) {\n    this.firstName = firstName\n    const names = [&#39;bill&#39;, &#39;mark&#39;, &#39;steve&#39;]\n\n    name.forEach((value, index) =&gt; {\n        console.log(value + &#39; &#39; + this.firstName)\n    })\n}\nconst kims = new Family(&#39;kim&#39;)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>정리</p>\n<ul>\n<li>this는 다른 언어와 다른 방식으로 사용된다.</li>\n<li>this는 누가 호출했느냐에 따라 결정된다.</li>\n<li>화살표 함수가 개꿀이다.</li>\n</ul>\n<p>참고</p>\n<ul>\n<li><a href=\"https://blueshw.github.io/2018/03/12/this/\">bono blog</a></li>\n</ul>","frontmatter":{"title":"[JavaScript] this 이해하기 ","date":"January 12, 2020"},"id":"18919e0d-a998-5146-9535-86477c4a02be"},"site":{"siteMetadata":{"title":"YoungGyu Blog","siteUrl":"http://answer.netlify.app","comment":{"disqusShortName":"lyg"}}}},"pageContext":{"slug":"/2020-01-12-this/","previous":{"fields":{"slug":"/2020-01-12-class/"},"frontmatter":{"title":"[JavaScript] 클래스(Class) 이해하기","tag":["Posts"],"layout":null}},"next":{"fields":{"slug":"/2020-01-15-changeNano/"},"frontmatter":{"title":"Ubuntu Linux환경에서 VSCODE 기본 텍스트편집기 변경 방법","tag":["Posts"],"layout":null}}}},"staticQueryHashes":["3668704128"]}